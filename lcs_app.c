// Copyright (C) 2022 Dialog Semiconductor
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in 
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/*******************************************************************************
          File:        lcs_app.c

       Version:        1

     Reference:        Section 10, Protocol Specification

       Purpose:        To implement application layer.

          Note:        None

         To Do:        None
*******************************************************************************/

/*******************************************************************************

 Overview:

 All messages coming into the application layer are handled by
 the APPReceive() function, which dispatches messages to the
 appropriate "Handle" function. Some of the functions explained here
 are local to the application layer and are not available to the application
 program. See "Local Function Prototypes" section below.

 HandleNormal():   Handles normal messages bound to the application program.
                   These are messages from other nodes that are bound to the
                   application program.

 HandleResponse(): Handles normal responses bound to the application program.
                   These are responses due to requests generated by the
                   application program.

 ProcessNV():      Handles incoming NV update and poll messages.
                   These are messages from other nodes or responses for
                   requests generated by the application layer.

 SendVar(): Takes care of network variable updates waiting to be sent.
            i.e implicit messages generated due to output network variable
            updates in the application program.

 PollVar(): Takes care of network variable polls waiting to be dispatched.
            These are messages explicitly generated by the application
            program by calling various forms of poll functions.
            The corresponding variables are input network variables.

 HandleNM(): Processes network management messages. Defn is in netmgmt.c.

 HandleND(): Processes network diagnostic messages. Defn is in netmgmt.c.

 HandleProxyResponse(): Handles responses from proxy messages. Defn is in
                        netmgmt.c. i.e responses received from the target node
                        are relayed back to the original node.

 HandleMsgCompletion(): Handles transaction completion indications from
                        transport, session, and network layers. Some of them
                        are for transactions originated by the application
                        layer itself. Others are for transactions originated
                        by the application program. In that case, the
                        application program is notified of these completion
                        events by a call to MsgCompletes or NVUpdateCompletes
                        function.

 TryMsgSend():    Helper function that moves messages in the application queue
                  to lower layer queues as appropriate.

 All messages generated by the application program (implicit or explicit)
 are buffered and then sent to lower layers by the APPSend() function.

 APPReset(): Takes care of the application layer reset operations. Allocates
             memory for all queue structures used by the application. Also,
             performs some initialization that are done after each reset.

 APPInit():  Takes care of initializations that are done only during
             power up.

 AddNV():    Takes care of network variable declarations in the application
             program. This function is normally called during power up
             to register all network variables in application program.
             This is done using the function AppInit(). Note that APPInit()
             is application layer function whereas AppInit() is application
             program function.

 The functions in this file also support the API interface used by application
 programs. e.g. msg_send, resp_send, propagate() etc.

 There is no implicit way of sending network variable updates in the reference
 implementation. The application program should call Propagate or one
 of its variants to actually propagate network variable updates.
*******************************************************************************/
/*------------------------------------------------------------------------------
Section: Includes
------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>

#include <lcs_eia709_1.h>
#include <lcs_node.h>
#include <lcs_queue.h>
#include <lcs_app.h>
#include <lcs_api.h>
#include <lcs_netmgmt.h>
#include <lcs_proxy.h>

/*------------------------------------------------------------------------------
Section: Constant and Macro Definitions
------------------------------------------------------------------------------*/
#define MAX_NV_SELF_DOC_LENGTH 1023

/*------------------------------------------------------------------------------
Section: Type Definitions
------------------------------------------------------------------------------*/
/* None */

/*------------------------------------------------------------------------------
Section: Globals
------------------------------------------------------------------------------*/
/* None */

/*------------------------------------------------------------------------------
Section: Local Function Prototypes
------------------------------------------------------------------------------*/
static void ProcessNV(APPReceiveParam *appReceiveParamPtr,
                      APDU            *apduPtr);
static void ProcessNVUpdate(APPReceiveParam *appReceiveParamPtr,
                            APDU            *apduPtr);
static void ProcessNVPoll(APPReceiveParam *appReceiveParamPtr,
                          APDU            *apduPtr);

static void HandleMsgCompletion(APPReceiveParam *appReceiveParamPtr,
                                APDU            *apduPtr);
static void HandleResponse(APPReceiveParam *appReceiveParamPtr,
                           APDU            *apduPtr);
static void HandleNormal(APPReceiveParam *appReceiveParamPtr,
                         APDU *apduPtr);

static Status  TryMsgSend(APPSendParam *appSendParamPtr,
                          APDU *apduPtr,
                          Queue   *tsaOutQPtr,
                          Queue   *nwOutQPtr);

static void ReinitMsgOut();
static void ReinitRespOut();

static Status PropagateThisIndex(int16 nvIndexIn, int16 primaryIndex);
static void   PropagateThisPrimary(int16 nvIndexIn);
static void   SendVar(void);

static Status PollThisIndex(int16 nvIndexIn);
static void   PollThisPrimary(int16 nvIndexIn);
static void   PollVar(void);

static Boolean IsArrayNV(int16 nvIndexIn,
                         uint16 *dimOut, int16 *indexOut);

static void ReinitMsgOut(void);
static void ReinitRespOut(void);
/*------------------------------------------------------------------------------
Section: Function Definitions
------------------------------------------------------------------------------*/

/*******************************************************************************
Function:  AllocSendResponse
Returns:   Status
Reference: None
Purpose:   Allocate and send a response.  
Comments:  None.
*******************************************************************************/
Status AllocSendResponse(RequestId reqId, Boolean nullResponse, Byte code, int len, Byte *pData)
{
	Status sts = FAILURE;
    if (!QueueFull(&gp->tsaRespQ))
	{
		TSASendParam *tsaSendParamPtr = QueueTail(&gp->tsaRespQ);
		APDU         *apduRespPtr     = (APDU *)(tsaSendParamPtr + 1);
        tsaSendParamPtr->altPathOverride = FALSE;
        tsaSendParamPtr->service      = RESPONSE;
        tsaSendParamPtr->reqId        = reqId;
        tsaSendParamPtr->apduSize     = len+1;
        tsaSendParamPtr->nullResponse = nullResponse;
		tsaSendParamPtr->flexResponse = FALSE;
        apduRespPtr->code.allBits     = code;
		// If the response doesn't fit, we just drop it (no error log for this).
        if (tsaSendParamPtr->apduSize <= gp->tsaRespBufSize)
        {
            memcpy((char *)apduRespPtr + 1, pData, len);
            EnQueue(&gp->tsaRespQ);
        }
		sts = SUCCESS;
    }
	return sts;
}

/*******************************************************************************
Function:  SendResponse
Returns:   Status
Reference: None
Purpose:   Send a response
Comments:  None.
*******************************************************************************/
Status SendResponse(RequestId reqId, Byte code, int len, Byte *pData)
{
	return AllocSendResponse(reqId, FALSE, code, len, pData);
}

/*******************************************************************************
Function:  SendNullResponse
Returns:   Status
Reference: None
Purpose:   Send a response
Comments:  None.
*******************************************************************************/
Status SendNullResponse(RequestId reqId)
{
	return AllocSendResponse(reqId, TRUE, 0, 0, NULL);
}

/*******************************************************************************
Function:  APPInit
Returns:   None
Reference: None
Purpose:   To perform initializations that should be done only
           once when the node is powered on. These are not
           done during node reset.
Comments:  None.
*******************************************************************************/
void APPInit(void)
{
    uint16  len;
    uint16  sizeNeeded;

    gp->unboundSelector       = 0x3FFF;  /* Countdown as we assign */
    gp->nvArrayTblSize        = 0;
    gp->nextBindableMsgTag    = 0;
    gp->nextNonbindableMsgTag = NUM_ADDR_TBL_ENTRIES;

    /****************************************************************************
      The SNVT area has the following layout (as expected by Network
      management tools):

      Header:
      uint16 length;
      uint8  numNetvars;
      uint8  version;
      uint8  msbNumNetvars;
      uint8  mtagCount;

      SNVT Desc:
      SNVTdescStruct[];   One struct (2 bytes) per var

      Node Self Doc String:
      char[];      Null terminated; just "\0" if empty

      SNVT Extension Records:
      one byte + various lengths

      Alias Field
      three bytes

      In the reference implementation, the SNVT information is
      stored in nmp->snvt, of type SNVTstruct. It can be
      stored in EEPROM too.

      In SNVTstruct the header fields are stored in explicit
      structure members, but the remaining information is stored
      in the 'sb' member which is simply a buffer of type char.

      When a network variable is added via AddNV():
      1. The Alias Field is saved.
      2. Room is made for the new SNVT Desc by moving all data
      past the last SNVT Desc forward by sizeof(SNVTdesc).
      The descPtr pointer indicates where the move starts.
      3. The new SNVT Desc is added (and descPtr is incremented).
      4. The new extension records are appended after the
      existing extension records.
      5. The Alias Field is restored (placed after the last
      extension record, and pointed to by aliasPtr).

      **************************************************************************/

    /* Initialize SNVT area */
    nmp->snvt.version       = 1;
    nmp->snvt.numNetvars    = 0;
    nmp->snvt.msbNumNetvars = 0;
    nmp->snvt.mtagCount     = 0;

    /* Copy NODE_DOC info if there is sufficient space */
    /* If not, init to null string. */
    len = strlen(NODE_DOC) + 1;
    if (len <= SNVT_SIZE - sizeof(AliasField))
    {
        strcpy((char *)&nmp->snvt.sb[0], NODE_DOC);
    }
    else
    {
        nmp->snvt.sb[0] = '\0';
        len = 1;
    }

    /* Initially, there is no network var related info */
    sizeNeeded = 6 + len + sizeof(AliasField);

    nmp->snvt.length = hton16(sizeNeeded);
    nmp->snvt.descPtr  = (SNVTdescStruct *)&nmp->snvt.sb[0];
    nmp->snvt.aliasPtr = (AliasField *)&nmp->snvt.sb[len];
    nmp->snvt.aliasPtr->bindingII  = TRUE;
    nmp->snvt.aliasPtr->queryStats = TRUE;
    nmp->snvt.aliasPtr->aliasCount = 0x3F;  /* host based node */
    nmp->snvt.aliasPtr->hostAlias  = hton16(NV_ALIAS_TABLE_SIZE);

    nmp->nvTableSize  = 0;
}

/*******************************************************************************
Function:  APPReset
Returns:   None
Reference: None
Purpose:   To initialize the Queues used by the application layer.
           May be some more.
Comments:  None.
*******************************************************************************/
void APPReset(void)
{
    uint16 queueItemSize;

    /* Allocate and Initialize Input Queue */
    gp->appInBufSize  =
        DecodeBufferSize((uint8)eep->readOnlyData.appInBufSize);
    gp->appInQCnt     = DecodeBufferCnt((uint8)eep->readOnlyData.appInBufCnt);
    queueItemSize    = gp->appInBufSize + sizeof(APPReceiveParam);

    if (QueueInit(&gp->appInQ, queueItemSize, gp->appInQCnt)
            != SUCCESS)
    {
        ErrorMsg("APPReset: Unable to init Input Queue.\n");
        gp->resetOk = FALSE;
        return;
    }

    /* Allocate and Initialize Output Queue */
    gp->appOutBufSize =
        DecodeBufferSize((uint8)eep->readOnlyData.appOutBufSize);
    gp->appOutQCnt    =
        DecodeBufferCnt((uint8)eep->readOnlyData.appOutBufCnt);
    queueItemSize    = gp->appOutBufSize + sizeof(APPSendParam);

    if (QueueInit(&gp->appOutQ, queueItemSize, gp->appOutQCnt)
            != SUCCESS)
    {
        ErrorMsg("APPReset: Unable to init Output Queue.\n");
        gp->resetOk = FALSE;
        return;
    }

    /* Allocate and Initialize Pri Output Queue */
    gp->appOutPriBufSize = gp->appOutBufSize;
    gp->appOutPriQCnt =
        DecodeBufferCnt((uint8)eep->readOnlyData.appOutBufPriCnt);
    queueItemSize    = gp->appOutPriBufSize + sizeof(APPSendParam);

    if (QueueInit(&gp->appOutPriQ, queueItemSize, gp->appOutPriQCnt)
            != SUCCESS)
    {
        ErrorMsg("APPReset: Unable to init Priority Output Queue.\n");
        gp->resetOk = FALSE;
        return;
    }

    /* Allocate Queue for NV output variable scheduling */
    gp->nvOutIndexQCnt    = MAX_NV_OUT;
    gp->nvOutIndexBufSize = 2 + MAX_NV_LENGTH;
    if (QueueInit(&gp->nvOutIndexQ, gp->nvOutIndexBufSize,
                  gp->nvOutIndexQCnt)  != SUCCESS)
    {
        ErrorMsg("APPReset: Unable to init NV Out Index Queue.\n");
        gp->resetOk = FALSE;
        return;
    }
    gp->nvOutStatus      = SUCCESS; /* Propagate succeeds if all the scheduled
                                      transactions complete successfully. */
    gp->nvOutCanSchedule = TRUE;
    gp->nvOutIndex       = 0; /* Not relevant initially */

    /* Allocate Queue for NV input variable scheduling */
    gp->nvInIndexQCnt = MAX_NV_IN;
    if (QueueInit(&gp->nvInIndexQ, 2, gp->nvInIndexQCnt)
            != SUCCESS)
    {
        ErrorMsg("APPReset: Unable to init NV In Index Queue.\n");
        gp->resetOk = FALSE;
        return;
    }
    gp->nvInDataStatus  = FAILURE; /* See node.h for usage */
    gp->nvInTranStatus  = SUCCESS; /* See node.h for usage */
    gp->nvInCanSchedule = TRUE;
    gp->nvInIndex       = 0; /* Not relevant initially */

    /* Set flags to correct state */
    gp->msgReceive      = FALSE;       /* TRUE if data is in gp->msgIn  */
    gp->respReceive     = FALSE;       /* TRUE if data is in gp->respIn */
    gp->callMsgFree     = FALSE;
    gp->callRespFree    = FALSE;
    gp->selectQueryFlag = FALSE;       /* FALSE until selected          */

    /* Init msg and resp */
    memset(&gp->msgIn,   0, sizeof(gp->msgIn));
    memset(&gp->msgOut,  0, sizeof(gp->msgOut));
    memset(&gp->respIn,  0, sizeof(gp->respIn));
    memset(&gp->respOut, 0, sizeof(gp->respOut));
    memset(&gp->nvInAddr, 0, sizeof(gp->nvInAddr));
    gp->nvArrayIndex = 0;
}

/*******************************************************************************
Function:  HandleMsgCompletion
Returns:   None
Reference: None
Purpose:   Pass a message completion event to the application
Comments:  None.
*******************************************************************************/
static void HandleMsgCompletion(APPReceiveParam *appReceiveParamPtr,
                                APDU            *apduPtr)
{
    Status stat;
    int16 primaryIndex, baseIndex;
    uint16 dim;

    if (appReceiveParamPtr->success)
    {
        stat = SUCCESS;
    }
    else
    {
        stat = FAILURE;
    }

	if (appReceiveParamPtr->proxy)
	{
		if (ProcessLtepCompletion(appReceiveParamPtr, apduPtr, stat) != SUCCESS)
		{
			// We'll try this again later...
			return;
		}
	}
    /* Since App Layer sends messages for NV update
       we may also get completion indication for these.
       See app.h for tag usage. */
    else if (appReceiveParamPtr->tag < 0)
    {
        /* Negative tags belong to application layer. */
        /* See app.h for explanation on how the tag is used. */
        if (MANUAL_SERVICE_REQUEST_TAG(appReceiveParamPtr->tag))
        {
            ; /* Ignore. Nothing to do. */
        }
        else
        {
            /* Must be a tag for NV message generated by application layer. */
            if (NV_POLL_TAG(appReceiveParamPtr->tag))
            {
                /* A network variable poll for an input variable will
                   succeed if both gp->nvInDataStatus and gp->nvInTranStatus succeed.
                   The gp->nvInDataStatus flag is updated by ProcessNVUpdate
                   function. */
                if (NV_LAST_TAG(appReceiveParamPtr->tag))
                {
                    primaryIndex   = gp->nvInIndex;
                    IsArrayNV(primaryIndex, &dim, &baseIndex);
                    gp->nvArrayIndex = primaryIndex - baseIndex;
                    /* Set poll completion status */
                    if ( (gp->nvInDataStatus == SUCCESS) &&
                            (gp->nvInTranStatus == SUCCESS)
                       )
                    {
                        stat = SUCCESS;
                    }
                    else
                    {
                        stat = FAILURE;
                    } /* poll completion status */
                    gp->nvInDataStatus = FAILURE; /* Reinit */
                    gp->nvInTranStatus = SUCCESS;
                    if (AppPgmRuns())
                    {
                        NVUpdateCompletes(stat, baseIndex, gp->nvArrayIndex);
                    }
                }
                else
                {
                    /* Update the index. Since the last tag does not have the
                       index, we need to save it. */
                    gp->nvInIndex = NV_INDEX_OF_TAG(appReceiveParamPtr->tag);
                    if (stat == FAILURE)
                    {
                        /* Set the flag to FAILURE as this transaction failed. */
                        gp->nvInTranStatus = FAILURE;
                    }
                }
                gp->nvInCanSchedule = TRUE; /* Resume scheduling */
            }
            else
            {
                /* NV_UPDATE_TAG */
                /* A network variable update for an output variable will
                   succeed if all the transactions scheduled for that
                   variable succeed. So, we need to update status flag. */
                if (NV_LAST_TAG(appReceiveParamPtr->tag))
                {
                    primaryIndex   = gp->nvOutIndex;
                    IsArrayNV(primaryIndex, &dim, &baseIndex);
                    gp->nvArrayIndex = primaryIndex - baseIndex;
                    stat = gp->nvOutStatus;
                    gp->nvOutStatus = SUCCESS; /* Reinit */
                    if (AppPgmRuns())
                    {
                        NVUpdateCompletes(stat, baseIndex, gp->nvArrayIndex);
                    }
                }
                else
                {
                    /* Set index. Update gp->nvOutStatus */
                    gp->nvOutIndex = NV_INDEX_OF_TAG(appReceiveParamPtr->tag);
                    if (stat == FAILURE)
                    {
                        gp->nvOutStatus = FAILURE;
                    }
                }
                gp->nvOutCanSchedule = TRUE; /* Resume scheduling */
            }
        }
    }
    else
    {
        /* Non-negative tags belong to application. */
        MsgCompletes(stat, appReceiveParamPtr->tag);
    }

    /* Message processing completed - remove it from queue */
    DeQueue(&gp->appInQ);
}

/*******************************************************************************
Function:  HandleResponse
Returns:   None
Reference: None
Purpose:   Handle incoming response message, passing it to the
           application via the gp->respIn global.
Comments:  None.
*******************************************************************************/
static void HandleResponse(APPReceiveParam *appReceiveParamPtr,
                           APDU            *apduPtr)
{
    /* Discard responses received when the node is not CNFG_ONLINE.
       In CNFG_ONLINE, the application can be either running (online)
       or not running (soft-offline). In either of these cases,
       we receive the response and store it in resp_in. Note that
       one reponse can be received at a time from resp_in. If the
       application is offline, then at most one response can be
       stored in resp_in */
    if (eep->readOnlyData.nodeState != CNFG_ONLINE)
    {
        DeQueue(&gp->appInQ); /* Discard response, nothing to do */
        return;
    }

    /* If the application has not processed the previous
     * response, then do nothing, we'll try again next time
     */
    if (gp->respReceive)
    {
        return;
    }

    /* Pass response to application */

    /* Setup gp->respIn */
    gp->respIn.tag  = appReceiveParamPtr->tag;
    gp->respIn.code = apduPtr->code.allBits;
    gp->respIn.len = appReceiveParamPtr->pduSize - 1;

    /* Copy domainIndex even if it is 2. respIn.domainIndex is
       only one bit anyway, so the result is 0 or 1 */
    gp->respIn.addr.domain = appReceiveParamPtr->srcAddr.dmn.domainIndex;
    gp->respIn.addr.flexDomain =
        (appReceiveParamPtr->srcAddr.dmn.domainIndex == 2);
    memcpy(&gp->respIn.addr.srcAddr,
           &appReceiveParamPtr->srcAddr.subnetAddr,
           sizeof(appReceiveParamPtr->srcAddr.subnetAddr));
    gp->respIn.addr.srcAddr.snodeFlag =
        appReceiveParamPtr->srcAddr.addressMode != MULTICAST_ACK;
    if (gp->respIn.addr.srcAddr.snodeFlag == 0)
    {
        memcpy(&gp->respIn.addr.destAddr.group,
               &appReceiveParamPtr->srcAddr.ackNode,
               sizeof(appReceiveParamPtr->srcAddr.ackNode));
    }
    else if (!gp->respIn.addr.flexDomain)
    {
        /* Fill snode entry only for non-flex domain response */
        gp->respIn.addr.destAddr.snode.subnet =
            eep->domainTable[appReceiveParamPtr->
                             srcAddr.dmn.domainIndex].subnet;
        gp->respIn.addr.destAddr.snode.node   =
            eep->domainTable[appReceiveParamPtr->
                             srcAddr.dmn.domainIndex].node;
    }
    if (gp->respIn.len <= gp->appInBufSize)
    {
        memcpy(gp->respIn.data, &apduPtr->data, gp->respIn.len);
        gp->respReceive = TRUE;
    }
    else
    {
        LCS_RecordError(WRITE_PAST_END_OF_APPL_BUFFER);
    }
    /* Message processing completed - remove it from queue */
    DeQueue(&gp->appInQ);
}

/*******************************************************************************
Function:  HandleNormal
Returns:   None
Reference: None
Purpose:   Handle incoming normal message
Comments:  If the application program is not running and a request message
           for the application program is received, we send a offline
           message. Note that the node state could be unconfigured or
           soft off-line.
*******************************************************************************/
static void HandleNormal(APPReceiveParam *appReceiveParamPtr,
                         APDU            *apduPtr)
{
    if (!AppPgmRuns())
    {
        if (appReceiveParamPtr->service == REQUEST)
        {
			Byte code = apduPtr->code.ff.ffFlag == 0x4 ? FOREIGN_FRAME_OFFLINE : APPL_MSG_OFFLINE;
			if (SendResponse(appReceiveParamPtr->reqId, code, 0, NULL) == FAILURE)
			{
				// Try again later
				return;
			}
		}
        DeQueue(&gp->appInQ); /* Discard msg, we're done with it when offline */
        return;
    }

    /* If the application has not processed the previous
     * message, then do nothing, we'll try again next time
     */
    if (gp->msgReceive)
    {
        return;
    }

    /* Pass message to application */

    /* Setup gp->msgIn */
    gp->msgIn.code = apduPtr->code.allBits;
    gp->msgIn.len = appReceiveParamPtr->pduSize - 1;
    if (gp->msgIn.len <= gp->appInBufSize)
    {
        memcpy(gp->msgIn.data, &apduPtr->data, gp->msgIn.len);
    }
    else
    {
        LCS_RecordError(WRITE_PAST_END_OF_APPL_BUFFER);
        DeQueue(&gp->appInQ);
        return;

    }

    gp->msgIn.authenticated = appReceiveParamPtr->auth;
    gp->msgIn.service = appReceiveParamPtr->service;
    gp->msgIn.reqId = appReceiveParamPtr->reqId;
    /* Fill in addr structure */
    gp->msgIn.addr.domain  = appReceiveParamPtr->srcAddr.dmn.domainIndex;
    gp->msgIn.addr.flexDomain =
        (appReceiveParamPtr->srcAddr.dmn.domainIndex == 2);
    /* Copy Source Address */
    memcpy(&gp->msgIn.addr.srcAddr,
           &appReceiveParamPtr->srcAddr.subnetAddr,
           sizeof(gp->msgIn.addr.srcAddr));
	// REMINDER - the whole point of msgInAddr is that it is really just a copy of the L3 addressing format.
	// Could reduce this code footprint by taking advantage of that fact.
    switch (appReceiveParamPtr->srcAddr.addressMode)
    {
    case BROADCAST:
        gp->msgIn.addr.format  = 0;
        gp->msgIn.addr.destAddr.bcastSubnet =
            appReceiveParamPtr->srcAddr.broadcastSubnet;
        break;
    case MULTICAST:
        gp->msgIn.addr.format  = 1;
        gp->msgIn.addr.destAddr.group =
            appReceiveParamPtr->srcAddr.group;
        break;
    case SUBNET_NODE:
        gp->msgIn.addr.format  = 2;
        if (!gp->msgIn.addr.flexDomain)
        {
            gp->msgIn.addr.destAddr.snode.subnet =
                eep->domainTable[gp->msgIn.addr.domain].subnet;
            gp->msgIn.addr.destAddr.snode.node  =
                eep->domainTable[gp->msgIn.addr.domain].node;
        }
        break;
    case UNIQUE_NODE_ID:
        gp->msgIn.addr.format  = 3;
        gp->msgIn.addr.destAddr.uniqueNodeId.subnet = 0; /* Not stored */
        memcpy(gp->msgIn.addr.destAddr.uniqueNodeId.uniqueId,
               eep->readOnlyData.uniqueNodeId,
               UNIQUE_NODE_ID_LEN);
        break;
    default:
        /* should not come here */
        gp->msgIn.addr.format  = 5; /* unknown. arbitrary 5 */
    }

    gp->msgReceive = TRUE;
    /* Message processing completed - remove it from queue */
    DeQueue(&gp->appInQ);
}


/*******************************************************************************
Function:  APPSend
Returns:   None
Reference: None
Purpose:   Process send side of the application layer
           Send one message of each of the following types if there is space.
            pri msg, nv update message, nv poll message, non-pri msg.
Comments:  Called by scheduler loop.
*******************************************************************************/
void APPSend(void)
{
    Queue         *appOutQPtr;
    Queue         *tsaOutQPtr;
    Queue         *nwOutQPtr;
    APPSendParam  *appSendParamPtr;
    APDU          *apduPtr;
    Status        status;

    if (gp->manualServiceRequest)
    {
        ManualServiceRequestMessage();
        gp->manualServiceRequest = FALSE;
    }

    /* Call MsgFree or RespFree implicitely if needed. */
    if (gp->callMsgFree)
    {
        MsgFree();
    }
    if (gp->callRespFree)
    {
        RespFree();
    }

    /* Send a priority message if we can */
    if (!QueueEmpty(&gp->appOutPriQ))
    {
        appOutQPtr      = &gp->appOutPriQ;
        tsaOutQPtr      = &gp->tsaOutPriQ;
        nwOutQPtr       = &gp->nwOutPriQ;
        appSendParamPtr = QueueHead(appOutQPtr);
        apduPtr         = (APDU *)(appSendParamPtr + 1);
        status           = TryMsgSend(appSendParamPtr, apduPtr,
                                      tsaOutQPtr, nwOutQPtr);
        if (status == SUCCESS)
        {
            /* We have moved this message. Discard it */
            DeQueue(appOutQPtr);
        }
    }

    /* Process one NV output variable scheduled, if any. */
    SendVar();

    /* Process one NV input variable (Poll) scheduled, if any. */
    PollVar();

    /* Send a non-priority message if we can */
    if (!QueueEmpty(&gp->appOutQ))
    {
        appOutQPtr      = &gp->appOutQ;
        tsaOutQPtr      = &gp->tsaOutQ;
        nwOutQPtr       = &gp->nwOutQ;
        appSendParamPtr = QueueHead(appOutQPtr);
        apduPtr         = (APDU *)(appSendParamPtr + 1);
        status          = TryMsgSend(appSendParamPtr, apduPtr,
                                     tsaOutQPtr, nwOutQPtr);
        if (status == SUCCESS)
        {
            /* We have moved this message. Discard it */
            DeQueue(appOutQPtr);
        }

    }
}


/*******************************************************************************
Function:  APPReceive
Returns:   None
Reference: None
Purpose:   Process receive side of the application layer.
Comments:  Called by scheduler loop.
*******************************************************************************/
void APPReceive(void)
{
    APPReceiveParam     *appReceiveParamPtr;
    APDU                *apduPtr;    /* ptr to APDU being received  */

    /* Check if anything to process */
    if (QueueEmpty(&gp->appInQ))
    {
        return; /* Nothing to process */
    }

    /* Set the pointer to APDU in appInQ */
    appReceiveParamPtr = QueueHead(&gp->appInQ);
    apduPtr            = (APDU *)(appReceiveParamPtr + 1);

    if (appReceiveParamPtr->indication == COMPLETION)
    {
        HandleMsgCompletion(appReceiveParamPtr,apduPtr);
    }
	else if (appReceiveParamPtr->proxy)
	{
		// A proxy response
        HandleProxyResponse(appReceiveParamPtr, apduPtr);
	}
    else if (appReceiveParamPtr->service == RESPONSE &&
             appReceiveParamPtr->tag >= 0)
    {
        /* The response belongs to the application program.
           Deliver it to the application irrespective of
           what type of message it is. If the application
           sends network management/diagnostic messages,
           it is its responsibility to handle them */
        HandleResponse(appReceiveParamPtr, apduPtr);
    }
    else if (appReceiveParamPtr->service == REQUEST && QueueFull(&gp->tsaRespQ))
    {
        // No room for a response so we'll get this later...
    }
    else if (apduPtr->code.nm.nmFlag == 0x3)
    {
        /* Network management messages */
        HandleNM(appReceiveParamPtr,apduPtr);
    }
    else if (apduPtr->code.nd.ndFlag == 0x5)
    {
        /* Network diagnostic messages */
        HandleND(appReceiveParamPtr,apduPtr);
    }
    else if (apduPtr->code.nv.nvFlag == 0x1)
    {
        /* Network variable update/poll messages */
        ProcessNV(appReceiveParamPtr,apduPtr);
    }
	else if (apduPtr->code.allBits == LT_APDU_ENHANCED_PROXY)
	{
		if (ProcessLTEP(appReceiveParamPtr, apduPtr) == SUCCESS)
		{
			DeQueue(&gp->appInQ);
		}
	}
    else if (apduPtr->code.ap.apFlag == 0x0 || apduPtr->code.ff.ffFlag == 0x4)
    {
        /* Messages bound to the application program. App Msg or Foriegn Frames. */
        HandleNormal(appReceiveParamPtr,apduPtr);
    }
    else
    {
        /* Not supported - just discard */
        DeQueue(&gp->appInQ);
    }

}

/*******************************************************************************
Function:  TryMsgSend
Returns:   SUCCESS if message sent, FAILURE otherwise
Reference: None
Purpose:   If room is available, move message from app queue to
           to tsa or nw output queue.
Comments:  None.
*******************************************************************************/
static Status TryMsgSend(APPSendParam *appSendParamPtr,
                         APDU *apduPtr,
                         Queue   *tsaOutQPtr,
                         Queue   *nwOutQPtr)
{
    TSASendParam  *tsaSendParamPtr;
    NWSendParam   *nwSendParamPtr;
    APDU          *apduSendPtr;

    /* If the address is bad, don't even bother sending it */
    if (appSendParamPtr->addr.noAddress == UNBOUND)
    {
        /* TurnAround is not possible with MsgOutAddr */
        MsgCompletes(SUCCESS, appSendParamPtr->tag);
        return(SUCCESS);
    }

    /* Simple unacknowledged messages go to network layer */
    if (appSendParamPtr->service == UNACKD)
    {
        if (QueueFull(nwOutQPtr))
        {
            return(FAILURE); /* Can't send message yet - try later */
        }

        nwSendParamPtr = QueueTail(nwOutQPtr);

        nwSendParamPtr->dropIfUnconfigured = TRUE;

        switch (appSendParamPtr->addr.noAddress)
        {
        case UNBOUND:
            /* Can't happen. We took care above */
            return(SUCCESS); /* doesn't matter what we return */
        case SUBNET_NODE:
            nwSendParamPtr->destAddr.addressMode = SUBNET_NODE;
            nwSendParamPtr->destAddr.dmn.domainIndex =
                appSendParamPtr->addr.snode.domainIndex;
            nwSendParamPtr->destAddr.addr.addr2a.subnet =
                appSendParamPtr->addr.snode.subnetID;
            nwSendParamPtr->destAddr.addr.addr2a.node   =
                appSendParamPtr->addr.snode.node;
            break;

        case UNIQUE_NODE_ID:
            nwSendParamPtr->destAddr.addressMode = UNIQUE_NODE_ID;
            nwSendParamPtr->destAddr.dmn.domainIndex =
                appSendParamPtr->addr.uniqueNodeId.domainIndex;
            nwSendParamPtr->destAddr.addr.addr3.subnet =
                appSendParamPtr->addr.uniqueNodeId.subnetID;
            memcpy(nwSendParamPtr->destAddr.addr.addr3.uniqueId,
                   appSendParamPtr->addr.uniqueNodeId.uniqueId, UNIQUE_NODE_ID_LEN);
            break;

        case BROADCAST:
            nwSendParamPtr->destAddr.addressMode = BROADCAST;
            nwSendParamPtr->destAddr.dmn.domainIndex =
                appSendParamPtr->addr.bcast.domainIndex;
            nwSendParamPtr->destAddr.addr.addr0 =
                appSendParamPtr->addr.bcast.subnetID;
            break;

        default: /* MUST BE GROUP FORMAT */
            nwSendParamPtr->destAddr.addressMode = MULTICAST;
            nwSendParamPtr->destAddr.dmn.domainIndex =
                appSendParamPtr->addr.group.domainIndex;
            nwSendParamPtr->destAddr.addr.addr1 =
                appSendParamPtr->addr.group.groupID;
            break;
        } /* switch */

        nwSendParamPtr->tag     = appSendParamPtr->tag;
        nwSendParamPtr->pduType = APDU_TYPE;
        nwSendParamPtr->deltaBL = 0;
        /* unacknowledged messages do not use alternate path */
        nwSendParamPtr->altPath = FALSE;
        nwSendParamPtr->pduSize = appSendParamPtr->len + 1;

        apduSendPtr = (APDU *)(nwSendParamPtr + 1);
        if (nwSendParamPtr->pduSize <= gp->nwOutBufSize)
        {
            memcpy(apduSendPtr, apduPtr, appSendParamPtr->len + 1);
            EnQueue(nwOutQPtr);
            /* Don't give completion yet. The network layer will send the
               completion indication in gp->appInQ */
        }
        else
        {
            /* Losing this packet as it is too large */
            MsgCompletes(FAILURE, appSendParamPtr->tag);
        }

        return(SUCCESS);
    }

    if (QueueFull(tsaOutQPtr))
    {
        return(FAILURE); /* Can't send message yet - try later */
    }

    /* All other service types go to TSA layers */
    tsaSendParamPtr = QueueTail(tsaOutQPtr);

    tsaSendParamPtr->dmn.domainIndex = 3;
    memcpy(&tsaSendParamPtr->destAddr,
           &appSendParamPtr->addr,
           sizeof(appSendParamPtr->addr));
    tsaSendParamPtr->service   = appSendParamPtr->service;
    tsaSendParamPtr->auth      = appSendParamPtr->authenticated;
    tsaSendParamPtr->reqId     = appSendParamPtr->reqId;
    tsaSendParamPtr->tag       = appSendParamPtr->tag;
    tsaSendParamPtr->apduSize  = appSendParamPtr->len + 1;
    tsaSendParamPtr->altPathOverride = FALSE;
	tsaSendParamPtr->priority  = tsaOutQPtr == &gp->tsaOutPriQ;

    apduSendPtr = (APDU *)(tsaSendParamPtr + 1);
    if (tsaSendParamPtr->apduSize <= gp->tsaOutBufSize)
    {
        memcpy(apduSendPtr, apduPtr, tsaSendParamPtr->apduSize);
        EnQueue(tsaOutQPtr);
    }
    else
    {
        /* Losing this message */
        MsgCompletes(FAILURE, appSendParamPtr->tag);
    }

    return(SUCCESS);
}

static void ReinitMsgOut(void)
{
    /* Reinit whatever fields need to be reinitialized after each msg_send */
    memset(&gp->msgOut, 0, sizeof(gp->msgOut));
}

static void ReinitRespOut(void)
{
    /* Reinit whatever fields need to be reinitialized after each resp_send */
    memset(&gp->respOut, 0, sizeof(gp->respOut));
}

/*******************************************************************************
Function:  MsgAlloc
Returns:   None
Reference: None
Purpose:   Determines if there is room for a message to be sent.
Comments:  None.
*******************************************************************************/
Boolean MsgAlloc(void)
{
    return(!QueueFull(&gp->appOutQ));
}

/* For nc compatibility */
Boolean msg_alloc(void)
{
    return(!QueueFull(&gp->appOutQ));
}

/*******************************************************************************
Function:  MsgAllocPriority
Returns:   None
Reference: None
Purpose:   Determines if there is room for a pri message to be sent.
Comments:  None.
*******************************************************************************/
Boolean MsgAllocPriority(void)
{
    return(!QueueFull(&gp->appOutPriQ));
}

/* For nc compatibility */
Boolean msg_alloc_priority(void)
{
    return(!QueueFull(&gp->appOutPriQ));
}

/*******************************************************************************
Function:  MsgSend
Returns:   None
Reference: None
Purpose:   The application calls this function to send a message.
           The message is placed in the application queue for
           processing by APPSend.
Comments:  None.
*******************************************************************************/
void MsgSend(void)
{
    Queue           *outQptr;
    APPSendParam    *appSendParamPtr;
    APDU            *apduPtr;
    AddrTableEntry  *ap;
    uint16           addrIndex;

    if (gp->msgOut.priorityOn)
    {
        outQptr = &gp->appOutPriQ;
    }
    else
    {
        outQptr = &gp->appOutQ;
    }

    /* Negative tags are reserved for application layer.
       Applications are not allowed to use negative tags */
    if (QueueFull(outQptr) || gp->msgOut.tag < 0 ||
            (gp->msgOut.service >= RESPONSE))
    {
        /* Bad Tag  OR
           Bad Service OR
           No place to put the message - discard it. This should
           not happen if application called MsgAlloc or
           MsgPriorityAlloc before forming the message */
        MsgCompletes(FAILURE, gp->msgOut.tag);
        ReinitMsgOut();
        return;
    }

    appSendParamPtr                = QueueTail(outQptr);
    appSendParamPtr->tag           = gp->msgOut.tag;
    appSendParamPtr->len           = gp->msgOut.len;
    appSendParamPtr->authenticated = gp->msgOut.authenticated;
    appSendParamPtr->service       = gp->msgOut.service;
    appSendParamPtr->addr          = gp->msgOut.addr;
    apduPtr                        = (APDU *)(appSendParamPtr + 1);
    apduPtr->code.allBits          = gp->msgOut.code;
    if (appSendParamPtr->len + 1 <= gp->appOutBufSize)
    {
        /* There is space in the queue item to copy data */
        memcpy((char *)apduPtr+1,
               gp->msgOut.data,
               appSendParamPtr->len);
    }
    else
    {
        /* We are losing this message as it is too big. */
        MsgCompletes(FAILURE, appSendParamPtr->tag);
        ReinitMsgOut();
        return;
    }

    /* Use implicit addressing if the tag value corresponds to an address
       table entry and the explicit address is unbound or turnaround.
       Thus explicit address can be used to override implicit addressing.
       Note that turnaround is not allowed with explicit messages. */
    if (appSendParamPtr->tag < NUM_ADDR_TBL_ENTRIES &&
            gp->msgOut.addr.noAddress == UNBOUND)
    {
        addrIndex = appSendParamPtr->tag;
        ap = AccessAddress(addrIndex); /* ap cannot be NULL */
        if (ap == NULL || ap->addrFormat == UNBOUND)
        {
            /* ap cannot be NULL, but we can be safe in checking it anyway.
               We lose this message as the address table entry is unbound
               or turnaround. */
            MsgCompletes(FAILURE, appSendParamPtr->tag);
            ReinitMsgOut();
            return;
        }
        memcpy(&appSendParamPtr->addr,
               ap,
               sizeof(MsgOutAddr));
    }
    EnQueue(outQptr);
    ReinitMsgOut();
}

/* For nc compatibility */
void msg_send(void)
{
    MsgSend();
}

/*******************************************************************************
Function:  MsgCancel
Returns:   None
Reference: None
Purpose:   The application calls this function to cancel a
           previous message allocation.
Comments:  None.
*******************************************************************************/
void MsgCancel(void)
{
    /* Nothing to do */
}

/* For nc compatibility */
void msg_cancel()
{
}

/*******************************************************************************
Function:  MsgFree
Returns:   None
Reference: None
Purpose:   Releases gp->msgIn (by clearning gp->msgReceive) so that the
           next message can be copied to gp->msgIn.
Comments:  None.
*******************************************************************************/
void MsgFree(void)
{
    gp->msgReceive = FALSE; /* TRUE when data is in gp->msgIn  */
    gp->callMsgFree = FALSE;
}

/* For nc compatibility */
void msg_free(void)
{
    gp->msgReceive = FALSE;
    gp->callMsgFree = FALSE;
}

/* TRUE if there is msg to be received */
Boolean  msgReceive(void)
{
    if (gp->msgReceive)
    {
        /* There is a message to be received. Need to call msg_free() */
        gp->callMsgFree = TRUE;
    }
    return(gp->msgReceive);
}

/* For nc compatibility */
Boolean  msg_receive(void)
{
    if (gp->msgReceive)
    {
        /* There is a message to be received. Need to call msg_free() */
        gp->callMsgFree = TRUE;
    }
    return(gp->msgReceive);
}

/*******************************************************************************
Function:  RespAlloc
Returns:   None
Reference: None
Purpose:   Check if there is space for sending a response.
Comments:  None.
*******************************************************************************/
Boolean RespAlloc(void)
{
    if (!QueueFull(&gp->tsaRespQ))
    {
        return(TRUE);
    }
    return(FALSE);
}

/* For nc compatibility */
Boolean resp_alloc(void)
{
    return(RespAlloc());
}

/*******************************************************************************
Function:  RespSend
Returns:   None
Reference: None
Purpose:   Reads gp->respOut, sends the response message
Comments:  None.
*******************************************************************************/
void RespSend(void)
{
    if (gp->respOut.reqId == 0)
    {
        /* Application did not initialize it. Let us use as default
           the reqId of message currently in gp->msgIn */
        gp->respOut.reqId = gp->msgIn.reqId;
    }

    /* If we can't send the response, we just discard it.  There should be space if application called
       RespAlloc before forming the response */
	AllocSendResponse(gp->respOut.reqId, gp->respOut.nullResponse, gp->respOut.code, gp->respOut.len, gp->respOut.data);
    ReinitRespOut();
}

/* For nc compatibility */
void resp_send(void)
{
    RespSend();
}

/*******************************************************************************
Function:  RespCancel
Returns:   None
Reference: None
Purpose:   The application calls this function to cancel a
           previous response allocation.
Comments:  None.
*******************************************************************************/
void RespCancel(void)
{
    /* Nothing to do */
}

/* For nc compatibility */
void resp_cancel(void)
{
}


/*******************************************************************************
Function:  RespFree
Returns:   None
Reference: None
Purpose:   Sets gp->respReceive to FALSE, which will allow a new
           response to be received.
Comments:  None.
*******************************************************************************/
void RespFree(void)
{
    gp->respReceive = FALSE; /* TRUE when data is in gp->respIn */
    gp->callRespFree = FALSE;
}

/* For nc compatibility */
void resp_free(void)
{
    gp->respReceive = FALSE;
    gp->callRespFree = FALSE;
}

/* Returns TRUE if there is resp to be received */
Boolean RespReceive(void)
{
    if (gp->respReceive)
    {
        /* There is a response to be received. Need to call resp_free() */
        gp->callRespFree = TRUE;
    }
    return(gp->respReceive);
}

/* For nc comptability */
Boolean resp_receive(void)
{
    if (gp->respReceive)
    {
        /* There is a response to be received. Need to call resp_free() */
        gp->callRespFree = TRUE;
    }
    return(gp->respReceive);
}


/*******************************************************************************
Function:  AddNV
Returns:   Network variable index. For arrays, the base index is returned.
Reference: None
Purpose:   Adds a new network variable. This involves
           adding an entry into nvConfigTable, nvFixedTable,
           SNVT information, if present etc.
           The return value is the index assigned to the variable.
           For arrays, each element is like a separate network
           variable. So, multiple entries are added to the
           tables. However, only the base index is returned.
Comments:  Format of the snvt.sb space is as follows:
   Self-Id for each network variable (SNVTdescStruct)
      (For arrays, one entry for each element)
   Node Self-Doc string.
   Self-Doc for each network variable
      (SNVTExtension & variable part)
   Self-Id for binding and status (AliasField)
*******************************************************************************/
int16 AddNV(NVDefinition *dp)
{
    uint16          i, nvSelfIdCnt;
    uint16          nvNameLen; /* Length for name of network variable. */
    uint16          docLen;    /* Length for self-doc for network var. */
    uint16          selectorVal;
    uint16          sizeNeeded;
    uint16          dim;
    uint16          jumpBy;    /* Number of bytes by which we shift sb array. */
    uint8           remainder,quotient;
    SNVTextension  *se;
    SNVTdescStruct *sd;
    AliasField      saveAlias; /* To save old alias field. */
    char           *p;
    char           *extPtr;  /* Points to where the new ext rec can be stored.*/
    char           *endOfSb; /* Points to end of sb array. */

    /* Initialize local pointers for structure information in dp so that
       we can use field names in these structures instead of explicit
       bit operations */
    se = (SNVTextension *)  &dp->snvtExt;
    /* snvtType info is not part of the snvtDesc. We only want to access the
       first byte of the structure, anyway. */
    sd = (SNVTdescStruct *) &dp->snvtDesc;

    /* First determine the number of entries to be added to nvConfigTable */
    if (dp->arrayCnt > 0)
    {
        dim = dp->arrayCnt; /* Array Variable. dim can still be 1. */
    }
    else
    {
        dim = 1; /* Simple variable */
    }

    if (dp->nvName == NULL || dp->varAddr == NULL)
    {
        return(-1); /* Network variable name and address is a must. */
    }

    if (nmp->nvTableSize + dim >  NV_TABLE_SIZE)
    {
        /* Not enough space in network variable table. */
        return(-1);
    }

    /* Save the original alias field. */
    saveAlias = *nmp->snvt.aliasPtr;

    /* Make endOfSb point to last element of sb array. We never want to go
       past this element */
    endOfSb = (char *)&nmp->snvt.sb[SNVT_SIZE - 1];

    /* Compute the size needed for this variable in SNVT structure. */
    if (dp->arrayCnt > 0 && dp->explodeArray)
    {
        /* We need one entry for each network variable. */
        nvSelfIdCnt = dim;
    }
    else
    {
        nvSelfIdCnt = 1;

    }
    sizeNeeded = sizeof(SNVTdescStruct) * nvSelfIdCnt;

    /* Fixed extRec. One for each entry in self id desc part. */
    if (sd->extRec) /* Check ext_rec bit */
    {
        /* Need space for fixed extension record too */
        sizeNeeded = sizeNeeded + sizeof(SNVTextension) * nvSelfIdCnt;
    }

    /* Variable Part of Extension Record. One for each entry in self id desc part. */
    /* See Page 9-23 of Technology Device Data Book Rev 3 */
    if (sd->extRec && se->mre)
    {
        sizeNeeded += nvSelfIdCnt; /* One byte for maximum rate */
    }
    if (sd->extRec && se->re)
    {
        sizeNeeded += nvSelfIdCnt; /* One byte for average rate */
    }
    if (sd->extRec && se->nm)
    {
        nvNameLen = strlen(dp->nvName) + 1;
        if (dp->arrayCnt > 0 && dp->explodeArray)
        {
            /* Need space for [ ] and up to 3 bytes for index */
            nvNameLen += 5;
            if (nvNameLen > 22)
            {
                return(-1);
            }
        }
        else if (nvNameLen > 17)
        {
            return(-1); /* Only up to 17 bytes supported */
        }

        sizeNeeded += (nvNameLen * nvSelfIdCnt);
    }
    if (sd->extRec && se->sd)
    {
        if (dp->nvSdoc)
        {
            docLen = strlen(dp->nvSdoc) + 1;
        }
        else
        {
            docLen = 1; /* For null character */
        }
        if (docLen > MAX_NV_SELF_DOC_LENGTH)
        {
            return(-1);
        }
        sizeNeeded += (docLen * nvSelfIdCnt);
    }

    if (sd->extRec & se->nc)
    {
        /* 16 bit count for # of network variables of this type. dim? */
        /* Reference implementation uses ver 1. */
        sizeNeeded += (2 * nvSelfIdCnt);
    }

    if ((char *)nmp->snvt.aliasPtr + sizeof(AliasField) + sizeNeeded
            > endOfSb)
    {
        /* No Space for the new snvt_desc_struct and extension rec. */
        return(-1);
    }

    /* For arrays, we need space in gp->nvArrayTblSize */
    if (dp->arrayCnt > 0 && gp->nvArrayTblSize == MAX_NV_ARRAYS)
    {
        /* No more space to save array information */
        return(-1);
    }

    /****************************************************************************
       dp->bind = TRUE ==> the network variable is bindable. Bindable
       variables are automatically given selector numbers in the range
       0x3000-0x3FFF (unbound network variables). bindable means they
       are currently unbound.

       dp->bind = FALSE ==> the network variable is non-bindable. i.e
       the application program assigns selector numbers and these variables
       are cannot be bound by the binder tools. In this case, it is
       the responsibility of the application program to assign these
       selector numbers in a reasonable way. For array variables, the
       application program indicates the selector for the first element
       and the other elements automatically get the previous selector
       numbers. The selector numbers count down.
    ****************************************************************************/

    /* We need dim many selectors. dim can be 1. */
    /* bindable variables use unboundSelectors   */
    selectorVal = gp->unboundSelector; /* initialize */
    if (dp->bind && gp->unboundSelector - dim + 1 < 0x3000)
    {
        /* Not enough selector numbers available for assigning */
        return(-1);
    }
    else if (!dp->bind)
    {
        /* selectors are specified by the application program.
           For arrays, only the selector for first element is
           given. Application program has the responsibility to
           assign unique selectors for all variables */

        selectorVal = dp->selector;
        /* We are using dim selectors. Make sure that all are in range */
        if (selectorVal + dim - 1 > 0x2FFF)
        {
            /* Nonbindable variables should have value in 0-0x2FFF */
            return(-1);
        }
    }

    /* Now selectorVal has the selector number to be assigned */

    /* Everything is fine. We are now ready to add this variable */

    /* Make extPtr point to where the new extension rec would go */
    /* aliasPtr points to the byte following the last byte of ext records */
    extPtr = (char *)nmp->snvt.aliasPtr + sizeof(SNVTdescStruct) * nvSelfIdCnt;

    /* Add entry or entries into the nvConfigTable and Fixed Table */
    /* Add one entry for each array element irrespective of whether it
       is exploded or not. */
    for (i = nmp->nvTableSize; i < nmp->nvTableSize + dim; i++)
    {
        /* nv config table */
        eep->nvConfigTable[i].nvPriority   = dp->priority;
        eep->nvConfigTable[i].nvDirection  = dp->direction;
        eep->nvConfigTable[i].nvSelectorHi = selectorVal >> 8;
        eep->nvConfigTable[i].nvSelectorLo = selectorVal & 0xFF;
        selectorVal--; /* automatic countdown - for both bind & non-bind */
        if (dp->bind)
        {
            gp->unboundSelector--; /* Update this as we just used up one */
        }
        eep->nvConfigTable[i].nvTurnaround = dp->turnaround;
        eep->nvConfigTable[i].nvService    = dp->service;
        eep->nvConfigTable[i].nvAuth       = dp->auth;
        eep->nvConfigTable[i].nvAddrIndex  = 0xF;

        /* nv fixed table */
        nmp->nvFixedTable[i].nvSync     = sd->nvSync;
        nmp->nvFixedTable[i].nvLength   = dp->nvLength;
        /* For arrays, make sure we compute the address of each item. */
        nmp->nvFixedTable[i].nvAddress  = (char *) dp->varAddr +
                                          (i - nmp->nvTableSize) * dp->nvLength;
    }

    /* If we are adding an array, save this info in gp->nvArrayTbl */
    /* Array with dim 1 is considered like an array */
    if (dp->arrayCnt > 0)
    {
        gp->nvArrayTbl[gp->nvArrayTblSize].nvIndex = nmp->nvTableSize;
        gp->nvArrayTbl[gp->nvArrayTblSize++].dim   = dim;
    }

    /****************************************************************************
    Format of the SNVT structure: (See APPReset for more info).
       snvtheader nv-self-id-desc node-self-doc nv-self-doc alias-field

       snvtheader is part of the nmp->snvt structure, its initial members.
       nmp->snvt.sb array is used for [nv-self-id-desc ... alias-field]
       alias-fields has binding and status information.
       nmp->snvt.descPtr points to beginning address of node-self-doc.
             i.e the address where the nv-self-id-desc for new network
             variable should be placed.
    ****************************************************************************/

    /* Add data to snvt structure */

    /* Update snvt descriptor count in snvt structure.
       nmp->snvt.msbNumNetvars is the most significant byte.
       nmp->snvt.numNetvars is the least significant byte.
       We want to add the value of dim to this number */
    quotient  = (nmp->snvt.numNetvars + nvSelfIdCnt) / 256;
    remainder = (nmp->snvt.numNetvars + nvSelfIdCnt) % 256;
    nmp->snvt.numNetvars     = remainder;
    nmp->snvt.msbNumNetvars += quotient;

    /* Now we need to move nv-self-doc and node-self-doc to make
       for self-id-desc for the network variable being added. */

    /* Make p point the last byte of nv-self-doc */
    p = (char *)nmp->snvt.aliasPtr - 1;
    /* Determine how many bytes everything moves by. */
    jumpBy = sizeof(SNVTdescStruct) * nvSelfIdCnt;
    while (p >= (char *)(nmp->snvt.descPtr))
    {
        *(p + jumpBy) = *p;
        p--;
    }

    /* Copy dp->snvtDesc information. One for each array item.     */
    /* All array items have the same information. i.e homogeneous. */
    sd = nmp->snvt.descPtr; /* Initialize */
    for (i = 0; i < nvSelfIdCnt; i++)
    {
        memcpy(sd, &dp->snvtDesc, 1); /* can't assign without casting. */
        sd->snvtTypeIndex = dp->snvtType;
        sd++;
    }
    nmp->snvt.descPtr = sd;

    sd = (SNVTdescStruct *)&dp->snvtDesc; /* Reinitialize */
    /* We are now ready to add the extension information */
    if (sd->extRec)
    {
        /* This variable has extension record following node-self-doc */
        /* Add one for each entry in the self id desc part. */
        for (i = 0; i < nvSelfIdCnt; i++)
        {
            /* extPtr has already been set to point to the right place    */
            /* se has already been set to point to dp->snvtExt            */
            /* extPtr is of type (Byte *)                                 */
            *extPtr = dp->snvtExt;
            extPtr += sizeof(SNVTextension);
            if (se->mre)
            {
                *extPtr = dp->maxrEst;
                extPtr++;
            }

            if (se->re)
            {

                *extPtr = dp->rateEst;
                extPtr++;
            }

            if (se->nm)
            {
                /* We need to store the name of the variable. null terminated. */
                nvNameLen = strlen(dp->nvName) + 1;
                if (dp->arrayCnt > 0 && dp->explodeArray)
                {
                    int index = i + 1;
                    /* We support maximum of 999 array items */
                    /* 999 is the maximum index we can represent with 3 digits */
                    sprintf(extPtr, "%s_", dp->nvName);
                    extPtr += nvNameLen; /* Should now point to null character */
                    if (index < 10)
                    {
                        sprintf(extPtr, "%1d", index); /* Single digit index */
                        extPtr++;
                    }
                    else if (index < 100)
                    {
                        sprintf(extPtr, "%2d", index); /* Double digit index */
                        extPtr += 2;
                    }
                    else
                    {
                        sprintf(extPtr, "%3d", index); /* Triple digit index */
                        extPtr += 3;
                    }
                    *extPtr = '\0';
                    extPtr++;
                } /* for j loop */
                else
                {
                    /* Simple variable. or Array with one entry. */
                    strcpy(extPtr, dp->nvName); /* Adds Null ch too */
                    extPtr += nvNameLen;
                } /* else */
            } /* if (se->nm) */

            if (se->sd)
            {
                if (dp->nvSdoc == NULL)
                {
                    *extPtr = '\0'; /* nvSdoc is missing */
                    extPtr++;
                }
                else
                {
                    docLen = strlen(dp->nvSdoc) + 1;
                    strcpy(extPtr, dp->nvSdoc);
                    extPtr += docLen;
                }
            }

            if (se->nc)
            {
                /* Store the dimension of the variable. Useful only for array
                   entered in SNVT that are not exploded. */
                *extPtr = dp->arrayCnt >> 8;   /* High order byte. */
                extPtr++;
                *extPtr = dp->arrayCnt & 0xFF; /* Low order byte */
                extPtr++;
            }
        } /* for */
    } /* if (sd->extRec) */

    /* Restore Alias */
    nmp->snvt.aliasPtr = (AliasField *)extPtr;
    *nmp->snvt.aliasPtr = saveAlias;
    extPtr = extPtr + sizeof(AliasField);

    /* Now extPtr points to the byte following the alias field */

    /* Update nmp->snvt.length */
    /* 6 below refers to the size of the header in snvt structure */
    sizeNeeded = (extPtr - (char *)&nmp->snvt.sb[0]) + 6;
    nmp->snvt.length  = hton16(sizeNeeded);

    nmp->nvTableSize += dim;

    return(nmp->nvTableSize - dim); /* Base index for arrays. */
}

/*******************************************************************************
Function:  ProcessNV
Returns:   None
Purpose:   To process an incoming network variable message.
           The message can be
            1. NV Update Message (ACKD, UNACKD, UNACKD_RPT)
            2. NV Poll Message. (REQUEST)
Comments:  In either case, the msg should have at least 2 bytes.
*******************************************************************************/
static void ProcessNV(APPReceiveParam *appReceiveParamPtr,
                      APDU            *apduPtr)
{
    if (appReceiveParamPtr->service == REQUEST)
    {
        ProcessNVPoll(appReceiveParamPtr, apduPtr);
    }
    else
    {
        ProcessNVUpdate(appReceiveParamPtr, apduPtr);
    }
}

/*******************************************************************************
Function:  ProcessNVPoll
Returns:   None
Purpose:   To process an incoming network variable poll message.
           The service should be a request.
Reference: The Technology Device Data Book Rev 3. Page 9-54
Comments:  The message should have 2 bytes.
           The network variable poll message is normally addressed
           to an output variable. However, we will allow either
           input or output variable to be polled. We simply respond
           with the data value of the matching variable.
           The application layer in reference implementation
           never sends network variable poll messages addressed
           to input variables. A network variable monitor tool
           might do this to get the value of input variables.
           (NVFetch is another way).

           If we are offline, send a response with no data.
           Else
               If we have one matching network variable (primary
               or alias), then send the response with the data.

               If we have two matching primary network variables
               then we ignore this message.

               If we don't have a matching network variable,
               then send a response with no data.

           The response is network variable update message
           with the direction flipped from what was received.

           If we have more than one primary variable with matching
           selector, then we have a problem. The sender is expecting
           only one response from each node receiving the poll message.
           So, it is not clear which one to send. If we have this
           situation, we will ignore this message and not respond
           at all. Note that it is not meaningful to have a primary
           and an alias of that primary to have the same selector.
           If the incoming variable is connected to two different primary
           variables on this node, then the incoming variable
           should not have been polled.
*******************************************************************************/
static void ProcessNVPoll(APPReceiveParam *appReceiveParamPtr,
                          APDU            *apduPtr)
{
    int16          i;
    uint8          nvDirection;
    uint16         selector, thisSelector;
    int16          matchingIndex;
    uint16         matchingPrimaryIndex;
    Queue         *tsaOutQPtr;
    TSASendParam  *tsaSendParamPtr;
    APDU          *apduRespPtr;
    NVStruct      *thisNVStrPtr, *matchingNVStrPtr;
    Boolean        authOK;
    Boolean        noData; /* Should data go out? */

    if (appReceiveParamPtr->pduSize != 2)
    {
        /* The message does not have correct size */
        LCS_RecordError(NV_MSG_TOO_SHORT);
        DeQueue(&gp->appInQ);
        return;
    }

    tsaOutQPtr = &gp->tsaRespQ;

    if (QueueFull(tsaOutQPtr))
    {
        /* Can't send response yet - try later. */
        return;
    }

    if (NodeUnConfigured())
    {
        /* Ignore this message in this state. See Tech Data Book Rev 3 p9-47. */
		SendNullResponse(appReceiveParamPtr->reqId);
        DeQueue(&gp->appInQ);
        return;
    }

    /* Determine selector and nvDirection for variable in the poll message. */
    selector    = (apduPtr->code.nv.nvCode << 8) | apduPtr->data[0];
    nvDirection = apduPtr->code.nv.nvDir;

    noData = TRUE; /* Assume that we will respond with no data */
    matchingIndex = -1; /* Initialize to indicate that no match yet. */

    /* If application is not running, then we should return with no data */
    /* We know that the node is configured at this point */
    if (AppPgmRuns())
    {
        /* Search for matching network variable. Search both primary
           and alias entries */
        for (i = 0; i < nmp->nvTableSize+NV_ALIAS_TABLE_SIZE; i++)
        {
            thisNVStrPtr     = GetNVStructPtr(i);
            thisSelector =
                (thisNVStrPtr->nvSelectorHi << 8) | thisNVStrPtr->nvSelectorLo;
            if (thisNVStrPtr->nvDirection == nvDirection &&
                    thisSelector              == selector)
            {
                if (matchingIndex == -1)
                {
                    matchingIndex = i; /* First match. */
                }
                else if (GetPrimaryIndex(matchingIndex) ==
                         GetPrimaryIndex(i))
                {
                    /* We have two distinct primary variables with same
                       selector. Ignore this message. */
					SendNullResponse(appReceiveParamPtr->reqId);
                    DeQueue(&gp->appInQ);
                    return;
                }
            }
            else
            {
                continue; /* Skip this entry. Does not match. */
            }
        }
    }

    /* Send the response with either data or nodata. */
    tsaSendParamPtr               = QueueTail(tsaOutQPtr);
    tsaSendParamPtr->altPathOverride = FALSE;
    tsaSendParamPtr->service      = RESPONSE;
    tsaSendParamPtr->nullResponse = FALSE;
	tsaSendParamPtr->flexResponse = FALSE;
    tsaSendParamPtr->reqId        = appReceiveParamPtr->reqId;
    apduRespPtr                   = (APDU *)(tsaSendParamPtr + 1);
    apduRespPtr->code.nv.nvFlag   = 0x1;
    apduRespPtr->code.nv.nvDir    = 1 - nvDirection; /* Opposite */
    /* Keep the same selector as the one received */
    apduRespPtr->code.nv.nvCode   = apduPtr->code.nv.nvCode;
    apduRespPtr->data[0]          = apduPtr->data[0];

    if (matchingIndex != -1)
    {
        noData               = FALSE;
        matchingPrimaryIndex = GetPrimaryIndex(matchingIndex);
        matchingNVStrPtr     = GetNVStructPtr(matchingIndex);
    }

    if (appReceiveParamPtr->auth ||
            matchingIndex == -1      ||
            !matchingNVStrPtr->nvAuth)
    {
        authOK = TRUE;
    }
    else
    {
        authOK = FALSE;
    }

    if (noData || matchingIndex == -1 || authOK == FALSE)
    {
        /* Send a response with no data */
        tsaSendParamPtr->apduSize = 2;
    }
    else
    {
        /* Send a response with data */
        if (NV_LENGTH(matchingPrimaryIndex) + 2 <= gp->tsaRespBufSize)
        {
            memcpy(&apduRespPtr->data[1],
                   NV_ADDRESS(matchingPrimaryIndex),
                   NV_LENGTH(matchingPrimaryIndex));
            tsaSendParamPtr->apduSize = 2 + NV_LENGTH(matchingPrimaryIndex);
        }
        else
        {
            tsaSendParamPtr->apduSize = 2;
        }
    }
    EnQueue(tsaOutQPtr);

    /* Message processing completed - remove it from queue */
    DeQueue(&gp->appInQ);
    return;
}

/*******************************************************************************
Function:  ProcessNVUpdate
Returns:   None
Purpose:   To process an incoming network variable update message.
           The service can be ACKD, UNACKD, UNACKD_RPT.
           The service can be RESPONSE too for poll responses.
Reference: The Technology Device Data Book Rev 3. Page 9-53
Comments:  The message should have > 2 bytes.
           The network variable update message is addressed
           to an input variable.

           If we are unconfigured then discard the message.

           There can be only one variable (primary or alias) with
           matching selector. Once a match is found, break.

           If we update one ore more network variables and we are
           not soft-offline then we don't give NVUpdateOccurs event.
           Otherwise, we do give NVUpdateOccurs to the application program.

           The prefix 'this' is used for local variables of this function
           related to information regarding network variables searched.
*******************************************************************************/
static void ProcessNVUpdate(APPReceiveParam *appReceiveParamPtr,
                            APDU            *apduPtr)
{
    int16          i;
    uint16         dataLength, matchingDataLength;
    uint8          nvDirection;
    uint16         selector, thisSelector;
    int16          matchingIndex;
    uint16         matchingPrimaryIndex;
    NVStruct      *thisNVStrPtr, *matchingNVStrPtr;
    Boolean        authOK;
    uint16         thisDim;
    int16          thisBaseIndex;

    if (appReceiveParamPtr->pduSize <= 2)
    {
        /* The message does not have any correct size or data field. */
        LCS_RecordError(NV_MSG_TOO_SHORT);
        DeQueue(&gp->appInQ);
        return;
    }

    if (eep->readOnlyData.nodeState == APPL_UNCNFG)
    {
        /* Ignore this message in this state. See Tech Data Book Rev 3 p9-47. */
        DeQueue(&gp->appInQ);
        return;
    }

    /* Determine selector and nvDirection for variable in the update message. */
    selector    = (apduPtr->code.nv.nvCode << 8) | apduPtr->data[0];
    nvDirection = apduPtr->code.nv.nvDir;
    if (nvDirection == NV_OUTPUT)
    {
        /* Ignore this message */
        LCS_RecordError(NV_UPDATE_ON_OUTPUT_NV);
        DeQueue(&gp->appInQ);
        return;
    }

    dataLength = appReceiveParamPtr->pduSize - 2; /* data length in message */

    /* Go through network input variables looking for a match. Once
       a match is found, update it and break. */
    matchingIndex = -1;
    for (i = 0; i < nmp->nvTableSize + NV_ALIAS_TABLE_SIZE; i++)
    {
        thisNVStrPtr = GetNVStructPtr(i);
        thisSelector =
            (thisNVStrPtr->nvSelectorHi << 8) | thisNVStrPtr->nvSelectorLo;
        if (thisNVStrPtr->nvDirection == NV_OUTPUT)
        {
            continue; /* Skip network output variables */
        }
        if (thisSelector == selector)
        {
            matchingIndex = i;
            break;
        }
    }

    if (matchingIndex != -1)
    {
        /* Need to update the network input variable   */
        /* matchingIndex can be primary or alias index */
        matchingPrimaryIndex = GetPrimaryIndex(matchingIndex);
        matchingDataLength   = NV_LENGTH(matchingPrimaryIndex);
        matchingNVStrPtr     = GetNVStructPtr(matchingPrimaryIndex);

        /* If the data size does not match, don't update. ignore. */
        if (dataLength != matchingDataLength)
        {
            LCS_RecordError(NV_LENGTH_MISMATCH);
            DeQueue(&gp->appInQ);
            return;
        }

        if (appReceiveParamPtr->auth || !matchingNVStrPtr->nvAuth)
        {
            authOK = TRUE;
        }
        else
        {
            authOK = FALSE;
        }

        if (!authOK)
        {
            DeQueue(&gp->appInQ);
            return; /* Skip the update as authentication did not succeed. */
        }

        /* Update the variable */
        if (dataLength > 0 && appReceiveParamPtr->service == RESPONSE)
        {
            /* We have a response to poll message. Update gp->nvInDataStatus flag. */
            gp->nvInDataStatus = SUCCESS;
        }
        memcpy(NV_ADDRESS(matchingPrimaryIndex),
               &apduPtr->data[1],
               dataLength);
        if (AppPgmRuns())
        {
            /* Notify application program only if it is running. */
            gp->nvInAddr.domain = appReceiveParamPtr->srcAddr.dmn.domainIndex;
            gp->nvInAddr.flexDomain =
                (appReceiveParamPtr->srcAddr.dmn.domainIndex == FLEX_DOMAIN);
            memcpy(&gp->nvInAddr.srcAddr,
                   &appReceiveParamPtr->srcAddr.subnetAddr,
                   sizeof(gp->nvInAddr.srcAddr));

            switch (appReceiveParamPtr->srcAddr.addressMode)
            {
            case BROADCAST:
                gp->nvInAddr.format  = 0;
                break;
            case MULTICAST:
                gp->nvInAddr.format  = 1;
                gp->nvInAddr.destAddr.group =
                    appReceiveParamPtr->srcAddr.group;
                break;
            case SUBNET_NODE:
                gp->nvInAddr.format  = 2;
                break;
            case UNIQUE_NODE_ID:
                gp->nvInAddr.format  = 3;
                break;
            default:
                /* should not come here */
                gp->nvInAddr.format  = 5; /* unknown */
            }
            IsArrayNV(matchingPrimaryIndex, &thisDim, &thisBaseIndex);
            gp->nvArrayIndex = matchingPrimaryIndex - thisBaseIndex;
            NVUpdateOccurs(thisBaseIndex, gp->nvArrayIndex);
        }
    }

    DeQueue(&gp->appInQ);
    return;
}


/*******************************************************************************
Function: PropagateThisIndex
Returns:  SUCCESS if the index is scheduled.
          FAILURE if the queue is full and hence not scheduled
                  or for sync network output variables, the queue
                  buffer size is not sufficient for this variable.
          INVALID if the index does not correspond to NV_OUTPUT
Purpose:  To schedule a specific index of a network variable
          (primary or alias), polled or not.
Comment:
          This function is local to this file and used by API functions
          Propagate, PropagateNV, and PropagateArrayNV.
          The address table entry for NV_OUTPUT can be turnarouud.
          So, if it is UNBOUND, then we check for turnaround field too.

          primaryIndex is passed for efficiency to avoid recomputation.
          nvIndexIn is always valid.
*******************************************************************************/
static Status PropagateThisIndex(int16 nvIndexIn, int16 primaryIndex)
{
    int16    *indexPtr;
    Queue    *indexQPtr;
    NVStruct *nvStructPtr;
    char     *valPtr;
    uint16    bufSize;

    nvStructPtr      = GetNVStructPtr(nvIndexIn);
 
    /* If the variable is not output, then we can't propagate. */
    if (nvStructPtr->nvDirection != NV_OUTPUT)
    {
        return(INVALID);
    }

    indexQPtr = &gp->nvOutIndexQ;
    bufSize   = gp->nvOutIndexBufSize;

    if (QueueFull(indexQPtr))
    {
        return(FAILURE); /* Could not schedule all. */
    }

    indexPtr  = QueueTail(indexQPtr);
    *indexPtr = nvIndexIn;
    if (NV_SYNC(primaryIndex))
    {
        /* Copy current value for synchronous variables */
        /* In the queue, the 2 byte index should follow the value */
        valPtr = (char *)(indexPtr + 1);
        if (NV_LENGTH(primaryIndex) <= bufSize - 2)
        {
            memcpy(valPtr, NV_ADDRESS(primaryIndex), NV_LENGTH(primaryIndex));
            EnQueue(indexQPtr);
        }
        else
        {
            return(FAILURE);
        }
    }
    else
    {
        EnQueue(indexQPtr);
    }

    return(SUCCESS);
}

/*******************************************************************************
Function: PropagateThisPrimary
Returns:  None
Purpose:  To schedule a specific primary network variable.
          If the variable is bound
          then
            this schedules the primary and any alias entries for this
            primary using PropagateThisIndex.
            If nothing was scheduled
            then
               generate failure completion event.
          else
            generate success completion event.
Comment:  After scheduling the primary and all related alias entries,
          this function will add -1 to the queue to indicate end.
*******************************************************************************/
void  PropagateThisPrimary(int16 nvIndexIn)
{
    int16    *indexPtr;
    Queue    *indexQPtr;
    uint16    count, dim;
    int16     baseIndex;
    int16     j;
    uint16    queueSpace;

    indexQPtr = &gp->nvOutIndexQ;

    queueSpace = QueueCnt(indexQPtr) - QueueSize(indexQPtr);

    /* Schedule primary network output variables for NVUpdate. */
    if (IsNVBound(nvIndexIn))
    {
        /* We need space for at least 2 entries to schedule.
           i.e we need to reserve one space for -1 at the end. */

        count = 0;
        if (queueSpace > 1 && PropagateThisIndex(nvIndexIn, nvIndexIn) == SUCCESS)
        {
            count++;
            queueSpace--;
        }
        /* Schedule all alias entries that map to this primary entry.
           If queue does not have much space, stop scheduling rest. */
        for (j = nmp->nvTableSize;
                j < nmp->nvTableSize + NV_ALIAS_TABLE_SIZE && queueSpace > 1;
                j++)
        {
            if (GetPrimaryIndex(j) != nvIndexIn)
            {
                continue;
            }
            if (PropagateThisIndex(j, nvIndexIn) == SUCCESS)
            {
                count++;
                queueSpace--;
            }
        }
        if (count == 0)
        {
            IsArrayNV(nvIndexIn, &dim, &baseIndex);
            gp->nvArrayIndex = nvIndexIn - baseIndex;
            NVUpdateCompletes(FAILURE, baseIndex, gp->nvArrayIndex);
        }
        else
        {
            /* Schedule a -1 to indicate end of indices for this primary. */
            /* There should be at least one space left in queue */
            indexPtr  = QueueTail(indexQPtr);
            *indexPtr = -1;
            EnQueue(indexQPtr);
        }
    }
    else
    {
        IsArrayNV(nvIndexIn, &dim, &baseIndex);
        gp->nvArrayIndex = nvIndexIn - baseIndex;
        NVUpdateCompletes(SUCCESS, baseIndex, gp->nvArrayIndex); /* Not bound. */
    }
}


/*******************************************************************************
Function:   Propagate
Returns:    None
Purpose:    To propagate all output network variables.
Comment:    This function is called by the application program to propagate
            all output network variables (declared as polled or not).

            Schedule all NV_OUTPUT indices with a valid address table
            entry regardless of whether it is primary or alias.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call SendVar function to actually send out
            NV Updates messages. If a network output variable is not
            bound, then there is no need to schedule it.

            The addressing information is implicit. If the network
            output variables does not correspond to an address table
            entry, then it can't be scheduled as we don't know how to
            generate the destination address.

            It is possible that not all variables can be scheduled
            due to space limitation in the queues. For guranteed
            scheduling of all possible network ouput variables, the
            nv output queue should be large enough.
*******************************************************************************/
void  Propagate(void)
{
    int16     i;

    /* Schedule primary network output variables. */
    for (i = 0; i < nmp->nvTableSize;  i++)
    {
        PropagateThisPrimary(i);
    }
}

/*******************************************************************************
Function:   PropagateNV
Returns:    None
Purpose:    To propagate a specific output network variable (simple or array)
Comment:    This function is called by the application program to propagate
            a specific network output variable (declared as polled or not).
            If the index corresponds to the first item of an array,
            then all items of the array are propagated.

            If the index does not correspond to first item of an array.
            only that index is propagated.

            The variable must be a primary variable. Alias entries that
            map to this primary (for array, any of the entries), which
            are bound to some valid address table entry. are also
            scheduled.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call SendVar function to actually send out
            NV Update messages.

            There is no gurantee that all possible variables are scheduled
            due to space limitation in the schedule queue. To ensure that
            this does not happen, the queue size for the scheduling should
            be made larger.

            The addressing information is implicit. If the network
            output variables does not correspond to an address table
            entry, then it can't be scheduled as we don't know how to
            generate the destination address.
*******************************************************************************/
void  PropagateNV(int16 nvIndexIn)
{
    uint16    dim;
    int16     baseIndex;
    int16     i;

    if (nvIndexIn < 0 || nvIndexIn >= nmp->nvTableSize )
    {
        return; /* Must be a valid primary index. */
    }


    IsArrayNV(nvIndexIn, &dim, &baseIndex);
    if (nvIndexIn != baseIndex)
    {
        dim = 1; /* nvIndexIn is not the first item of array */
    }

    /* Scheduled one or more (for array) primary indices. */
    /* For array, nvIndexIn = baseIndex */
    for (i = nvIndexIn; i < nvIndexIn + dim; i++)
    {
        PropagateThisPrimary(i);
    }
}


/*******************************************************************************
Function:   PropagateArrayNV
Returns:    None
Purpose:    To propagate a specific element of an array output network
            variable or any other network variable (i.e non-array nv).
Comment:    This function is called by the application program to propagate
            a specific item of an array network output variable
            (declared as polled or not) or a simple network variable.

            Once the primary is scheduled, we also schedule alias
            entries that map to this primary to make sure that we
            reach all possible input connections.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call SendVar function to actually send out
            NV Update messages.

            The addressing information is implicit. If the network
            input variables does not correspond to an address table
            entry, then it can be scheduled as we don't know how to
            generate the destination address.

            If arrayNVIndexIn corresponds to the baseindex of an array
            network variable then indexIn is used to compute the specific
            item of the array. Otherwise indexIn is set to 0 so that this
            function will propagate the given index only (a specific array
            item or a simple network variable).
*******************************************************************************/
void  PropagateArrayNV(int16 arrayNVIndexIn, int16 indexIn)
{
    uint16    dim;
    int16     baseIndex;
    int16     nvIndex;

    if (arrayNVIndexIn < 0 || arrayNVIndexIn >= nmp->nvTableSize)
    {
        return; /* Invalid index. */
    }

    /* if arrayNVIndexIn is not an array variable, then dim is set to 1
       and baseIndex is set to arrayNVIndexIn by IsArrayNV function */
    if (!IsArrayNV(arrayNVIndexIn, &dim, &baseIndex) )
    {
        indexIn = 0; /* Simple network variable */
    }
    else if (baseIndex != arrayNVIndexIn)
    {
        indexIn = 0; /* Any other array item. don't use indexIn passed. */
    }

    if (indexIn < 0 || indexIn >= dim)
    {
        return; /* Invalid index */
    }

    nvIndex = arrayNVIndexIn + indexIn;
    PropagateThisPrimary(nvIndex);
}

/*******************************************************************************
Function:  SendVar
Returns:   None.
Purpose:   Generates NV Update message for the given index.
           The given index can be either primary or alias.
           For sync network output variables, we are also
           given the corresponding value. For nonsync variables,
           valPtr is null and current value is used.

           If the network output variable has nvTurnaround on,
           then we need to search for a network input variable with
           matching selector number. Once found, we update it, and
           send NVUpdateOccurs event to the application program.
           Note that we search through both primary and alias
           entries for the turnaround. If a primary is connected to this
           output variables, we will find it eventually either direcly
           or indirectly (via alias).

Comments:
           We need to handle only the given index. Propagate functions
           take care of scheduling all needed alias indices properly.
           Implicit NV Updates are handleded through Propagate.

           It is possible that variables are scheduled, but by the time
           they are processed in this function, the application is
           offline or the node is unconfigured. So, check for this
           too before updating network variables for turnaround.

           Also, it is possible that some attributes of the variable
           has been changed by a network management tool after the
           index was scheduled.

           If the index is -1, then it represents the end of scheduling for a
           primary. Generate a message to transport layer with a special tag
           that will be recognized and sent back immediately in the
           indication to application layer.
*******************************************************************************/
static void SendVar()
{
    Queue          *indexQPtr;
    int16           i;           /* For loop. */
    uint16          bufSize;        /* bufSize for the target queue */
    int16           nvIndex;
    int16           primaryIndex;   /* For nvIndex. */
    uint16          nvLength;       /* For nvIndex. */
    uint16          selector;       /* For nvIndex. */
    Byte           *nvPtr;          /* For nvIndex. Points to storage. */
    uint16          dimIn;          /* For input network variable */
    int16           primaryIndexIn; /* For input network variable */
    int16           baseIndexIn;    /* For input network variable */
    uint16          nvLengthIn;     /* For input network variable */
    Byte           *nvPtrIn;        /* For input network variable */
    uint16          selectorIn;     /* For input network variable */
    Queue          *nwOutQPtr, *tsaOutQPtr;
    TSASendParam   *tsaSendParamPtr;
    NWSendParam    *nwSendParamPtr;
    APDU           *apduPtr;
    NVStruct       *nvStrPtr, *nvStrPtrIn;
    uint16          addrIndex;
    AddrTableEntry *ap;
    Boolean         turnAroundOnly; /* does not mean turnaround for sure. Means that
                                      the variable does not have addr table entry
                                      or the address table entry is unbound or
                                      it is turnaround entry. */
    int16          *indexPtr;
    char           *valPtr;

    indexQPtr = &gp->nvOutIndexQ;

    if (!gp->nvOutCanSchedule || QueueEmpty(indexQPtr))
    {
        return; /* Nothing to do. */
    }
    indexPtr  = QueueHead(indexQPtr);
    nvIndex   = *indexPtr;
    valPtr    = (char *)(indexPtr + 1);

    /* If the node enters unconfigued state before processing this nv update
       we do not want to schedule these indices. We simply do nothing and wait
       for the node to go configured. */
    if (eep->readOnlyData.nodeState == APPL_UNCNFG)
    {
        return;
    }

    /* nvIndexIn > 0 => nv variable. nvIndex == -1 => end of scheduling */
    if (nvIndex >= 0)
    {
        /* Make nvStrPtr point to the right NVStruct for nvIndexIn */
        nvStrPtr     = GetNVStructPtr(nvIndex);
        primaryIndex = GetPrimaryIndex(nvIndex);
        nvPtr        = NV_ADDRESS(primaryIndex);
        nvLength     = NV_LENGTH(primaryIndex);
        selector     = (nvStrPtr->nvSelectorHi << 8) | nvStrPtr->nvSelectorLo;
        addrIndex    = nvStrPtr->nvAddrIndex;
        /* The variable is turnaround only if addrIndex is 0xF or the address
           table entry is unbound (turnaround or not). */
        /* *** START INFORMATIVE - Unbound Network Variable */
        /* It is acceptable to require that turnaround NVs have an address table
         * entry assigned.  This entry may be used for determining retry counts
         * and tx_timer values for retrying in the event of resource problems such
         * as input buffer inavailability.  Network management tools are expected
         * to assign an address table entry even if using unackd service. */
        /* *** END INFORMATIVE - Unbound Network Variable */
        turnAroundOnly  = addrIndex == 0xF ||
                          eep->addrTable[addrIndex].addrFormat == UNBOUND;

        if (nvStrPtr->nvPriority)
        {
            tsaOutQPtr = &gp->tsaOutPriQ;
            nwOutQPtr  = &gp->nwOutPriQ;
            if (nvStrPtr->nvService == UNACKD)
            {
                bufSize = gp->nwOutPriBufSize;
            }
            else
            {
                bufSize = gp->tsaOutPriBufSize;
            }
        }
        else
        {
            tsaOutQPtr = &gp->tsaOutQ;
            nwOutQPtr  = &gp->nwOutQ;
            if (nvStrPtr->nvService == UNACKD)
            {
                bufSize = gp->nwOutBufSize;
            }
            else
            {
                bufSize = gp->tsaOutBufSize;
            }
        }
    }
    else
    {
        /* Let us use tsaOutQ for the special message */
        tsaOutQPtr = &gp->tsaOutQ;
    }

    if (nvIndex == -1 || !turnAroundOnly)
    {
        /* We need to make sure that we have space in transport or network
           layer. If there is no space, we should return without doing any
           processing.
           NV variable messages can be ACK, UNACK, UNACKD_RPT */
        if (nvIndex == -1)
        {
            if (QueueFull(tsaOutQPtr))
            {
                return;
            }
        }
        else if (nvStrPtr->nvService == UNACKD && QueueFull(nwOutQPtr))
        {
            return;
        }
        else if (nvStrPtr->nvService != UNACKD && QueueFull(tsaOutQPtr))
        {
            return;
        }
    }

    if (nvIndex == -1)
    {
        /* Form a message with a special tag to transport layer. */
        tsaSendParamPtr              = QueueTail(tsaOutQPtr);
        tsaSendParamPtr->altPathOverride = FALSE;
        tsaSendParamPtr->service     = ACKD;
        tsaSendParamPtr->tag         = NV_UPDATE_LAST_TAG_VALUE;
        tsaSendParamPtr->apduSize    = 0;
		tsaSendParamPtr->priority	 = tsaOutQPtr == &gp->tsaOutPriQ;
        EnQueue(tsaOutQPtr);
        gp->nvOutCanSchedule = FALSE; /* Only one at a time. */
        DeQueue(indexQPtr);
        return;
    }


    /* If the variable is flagged as turnaround, then we look for first
       network input variable with matching selector number. Once found,
       we update that input variable, and then send NVUpdateOccurs event
       to the application program. We break as soon as first match is found. */
    if (nvStrPtr->nvTurnaround)
    {
         for (i = 0; i < nmp->nvTableSize+NV_ALIAS_TABLE_SIZE; i++)
        {
            nvStrPtrIn  = GetNVStructPtr(i);
            selectorIn  =
                (nvStrPtrIn->nvSelectorHi << 8) | nvStrPtrIn->nvSelectorLo;
            /* If this variable is not input or does not have matching selector,
               then skip this entry */
            if (nvStrPtrIn->nvDirection != NV_INPUT ||
                    selector != selectorIn)
            {
                continue; /* Not a matching entry */
            }
            /* Found a matching turnaroud entry for nvIndexIn */
            primaryIndexIn = GetPrimaryIndex(i);
            nvPtrIn        = NV_ADDRESS(primaryIndexIn);
            nvLengthIn     = NV_LENGTH(primaryIndexIn);
            if (nvLength != nvLengthIn)
            {
                break; /* selector matches but length does not */
            }
            memcpy(nvPtrIn, nvPtr, nvLength);
            /* Notify application if it is running */
            if (AppPgmRuns())
            {
                IsArrayNV(primaryIndexIn, &dimIn, &baseIndexIn);

                gp->nvInAddr.format = 4; /* TURNAROUND */
                memset(&gp->nvInAddr.srcAddr, 0, sizeof(SubnetAddress));
                gp->nvInAddr.domain = 0; /* Not relevant */
                gp->nvArrayIndex    = primaryIndexIn - baseIndexIn;
                NVUpdateOccurs(baseIndexIn, gp->nvArrayIndex);
            }

            break; /* break after first match */
        } /* for */
    } /* if */

    if (turnAroundOnly)
    {
        /* Completion event is given in HandleMsgCompletion function */
        /* Since there is nothing actually scheduled, no need to clear
           gp->nvOutCanSchedule flag. */
        /* Since this index does not go through HandleMsgCompletion, we need
           to set gp->nvOutIndex here. This is to take care of the case when
           a variable is turndaround only with no alias. In this case this index
           is followed by -1 in the queue. Hence, the gp->nvOutIndex would never
           be initialized when HandleMsgCompletion gets NV_UPDATE_LAST_TAG_VALUE.
           Explicit initialization here will fix the problem. */
        gp->nvOutIndex = GetPrimaryIndex(nvIndex);
        DeQueue(indexQPtr);
        return;
    }

    gp->nvOutCanSchedule = FALSE; /* Only one index at a time */
    DeQueue(indexQPtr);

    /* Build and send network variable update message. */
    ap = AccessAddress(addrIndex); /* ap can't be null. */
    /* Fail if we don't have sufficient space in the target queue. */
    if (2 + nvLength > bufSize)
    {
        /* Discard this index as the space is not sufficient */
        return;
    }

    if (nvStrPtr->nvService != UNACKD)
    {
        /* The message should go to the transport layer */
        tsaSendParamPtr              = QueueTail(tsaOutQPtr);
        tsaSendParamPtr->altPathOverride = FALSE;
        tsaSendParamPtr->dmn.domainIndex = COMPUTE_DOMAIN_INDEX;
        *(AddrTableEntry *)(&tsaSendParamPtr->destAddr) = *ap;
        tsaSendParamPtr->service     = (ServiceType)nvStrPtr->nvService;
        tsaSendParamPtr->auth        = nvStrPtr->nvAuth;
        /* See app.h for information on tag usage. */
        tsaSendParamPtr->tag         = GET_NV_UPDATE_TAG(primaryIndex);
        apduPtr                      = (APDU *)(tsaSendParamPtr + 1);
        apduPtr->code.nv.nvFlag      = 0x1;
        apduPtr->code.nv.nvDir       = NV_INPUT;
        apduPtr->code.nv.nvCode      = nvStrPtr->nvSelectorHi;
        apduPtr->data[0]             = nvStrPtr->nvSelectorLo;
        tsaSendParamPtr->apduSize    = 2 + nvLength;
        if (NV_SYNC(primaryIndex))
        {
            /* Send value given */
            memcpy(&apduPtr->data[1], valPtr, nvLength);
        }
        else
        {
            /* Send the most current value */
            memcpy(&apduPtr->data[1], nvPtr, nvLength);
        }

        EnQueue(tsaOutQPtr);
        return;
    }

    /* The message is for the network layer */
    nwSendParamPtr = QueueTail(nwOutQPtr);
    nwSendParamPtr->dropIfUnconfigured = TRUE;
    nwSendParamPtr->tag = GET_NV_UPDATE_TAG(primaryIndex);

    switch (ap->addrFormat)
    {
    case SUBNET_NODE:
        nwSendParamPtr->destAddr.addressMode = SUBNET_NODE;
        nwSendParamPtr->destAddr.dmn.domainIndex =
            ap->snodeEntry.domainIndex;
        nwSendParamPtr->destAddr.addr.addr2a.subnet =
            ap->snodeEntry.subnetID;
        nwSendParamPtr->destAddr.addr.addr2a.node   =
            ap->snodeEntry.node;
        break;
    case BROADCAST:
        nwSendParamPtr->destAddr.addressMode = BROADCAST;
        nwSendParamPtr->destAddr.dmn.domainIndex =
            ap->bcastEntry.domainIndex;
        nwSendParamPtr->destAddr.addr.addr0 =
            ap->bcastEntry.subnetID;
        break;

    default:
        /* Since the address table entry can't be unbound or turnaround,
           we must have group entry */
        nwSendParamPtr->destAddr.addressMode = MULTICAST;
        nwSendParamPtr->destAddr.dmn.domainIndex =
            ap->groupEntry.domainIndex;
        nwSendParamPtr->destAddr.addr.addr1 =
            ap->groupEntry.groupID;
    } /* switch */

    nwSendParamPtr->pduType     = APDU_TYPE;
    nwSendParamPtr->deltaBL     = 0; /* No ack generated */
    nwSendParamPtr->altPath     = FALSE;
    nwSendParamPtr->pduSize     = 2 + nvLength;
    apduPtr                     = (APDU *)(nwSendParamPtr + 1);
    apduPtr->code.nv.nvFlag     = 0x1;
    apduPtr->code.nv.nvDir      = NV_INPUT;
    apduPtr->code.nv.nvCode     = nvStrPtr->nvSelectorHi;
    apduPtr->data[0]            = nvStrPtr->nvSelectorLo;
    if (NV_SYNC(primaryIndex))
    {
        /* Send value given. */
        memcpy(&apduPtr->data[1], valPtr, nvLength);
    }
    else
    {
        /* Send the most current value. */
        memcpy(&apduPtr->data[1], NV_ADDRESS(primaryIndex), nvLength);
    }
    EnQueue(nwOutQPtr);

    return;
}

/*******************************************************************************
Function: PollThisIndex
Returns:  SUCCESS if the index is scheduled.
          FAILURE if the queue is full and hence not scheduled.
          INVALID if the index does not correspond to NV_INPUT.
Purpose:  To schedule a specific index of a network variable
          (primary or alias).
Comment:
          This function is local to this file and used by API functions
          Poll, PollNV, and PollArrayNV.
          nvIndexIn is always valid.
*******************************************************************************/
static Status PollThisIndex(int16 nvIndexIn)
{
    int16    *indexPtr;
    Queue    *indexQPtr;
    NVStruct *nvStructPtr;

    nvStructPtr      = GetNVStructPtr(nvIndexIn);
    if (nvStructPtr->nvDirection != NV_INPUT)
    {
        return(INVALID);
    }

    indexQPtr = &gp->nvInIndexQ;

    if (QueueFull(indexQPtr))
    {
        return(FAILURE); /* Could not schedule all. */
    }
    indexPtr  = QueueTail(indexQPtr);
    *indexPtr = nvIndexIn;
    EnQueue(indexQPtr);
    return(SUCCESS);
}

/*******************************************************************************
Function: PollThisPrimary
Returns:  None
Purpose:  To schedule a specific primary network variable.
          If the variable is bound
          then
            this schedules the primary and any alias entries for this
            primary using PollThisIndex.
            If nothing was scheduled
            then
               generate failure completion event.
          else
            generate success completion event.
Comment:  None.
*******************************************************************************/
void  PollThisPrimary(int16 nvIndexIn)
{
    int16    *indexPtr;
    Queue    *indexQPtr;
    uint16    count, dim;
    int16     baseIndex;
    int16     j;
    uint16    queueSpace;

    indexQPtr = &gp->nvInIndexQ;

    queueSpace = QueueCnt(indexQPtr) - QueueSize(indexQPtr);

    /* Schedule primary network input variables for poll */
    if (IsNVBound(nvIndexIn))
    {
        /* We need space for at least 2 entries to schedule.
        i.e we need to reserve one space for -1 at the end. */
        count = 0;
        if (queueSpace > 1 && PollThisIndex(nvIndexIn) == SUCCESS)
        {
            count++;
            queueSpace--;
        }
        /* Schedule all alias entries that map to this primary entry.
           If queue does not have much space, stop scheduling rest. */
        for (j = nmp->nvTableSize;
                j < nmp->nvTableSize + NV_ALIAS_TABLE_SIZE && queueSpace > 1;
                j++)
        {
            if (GetPrimaryIndex(j) != nvIndexIn)
            {
                continue;
            }
            if (PollThisIndex(j) == SUCCESS)
            {
                count++;
                queueSpace--;
            }
        }
        if (count == 0)
        {
            IsArrayNV(nvIndexIn, &dim, &baseIndex);
            gp->nvArrayIndex = nvIndexIn - baseIndex;
            NVUpdateCompletes(FAILURE, baseIndex, gp->nvArrayIndex);
        }
        else
        {
            /* Schedule -1 to indicate end of indices for this primary. */
            /* There should be at least one space left in queue */
            indexPtr  = QueueTail(indexQPtr);
            *indexPtr = -1;
            EnQueue(indexQPtr);
        }
    }
    else
    {
        IsArrayNV(nvIndexIn, &dim, &baseIndex);
        gp->nvArrayIndex = nvIndexIn - baseIndex;
        NVUpdateCompletes(SUCCESS, baseIndex, gp->nvArrayIndex); /* Not bound. */
    }
}

/*******************************************************************************
Function:   Poll
Returns:    None
Purpose:    To poll all input network variables.
Comment:    This function is called by the application program to poll
            all network input variables.

            Schedule all NV_INPUT indices with a valid address table
            entry regardless of whether it is primary or alias.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call PollVar function to actually send out
            polling requests.

            It is possible that not all variables can be scheduled
            due to space limitation in the queues. For guranteed
            scheduling of all possible network input variables, the
            polling queue should be large enough.

            NVUpdateCompletes for input variables means that they
            are completion indication of corresponding poll requests.
*******************************************************************************/
void  Poll(void)
{
    int16     i;

    /* Schedule primary network input variables for poll */
    for (i = 0; i < nmp->nvTableSize;  i++)
    {
        PollThisPrimary(i);
    }
}

/*******************************************************************************
Function:   PollNV
Returns:    None
Purpose:    To poll a specific input network variable (simple or array)
Comment:    This function is called by the application program to poll
            a specific network input variable.
            If the index corresponds to the first item of an array,
            then all items of the array are polled.

            If the index does not correspond to first item of an array.
            only that index is polled.

            The variable must be a primary variable. All alias entries
            for this primary are also scheduled.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call PollVar function to actually send out
            polling requests.

            There is no gurantee that all possible variables are scheduled
            due to space limitation in the schedule queue. To ensure that
            this does not happen, the queue size for the scheduling should
            be made larger.

            The addressing information is implicit. If the network
            input variables does not correspond to an address table
            entry, then it can't be scheduled as we don't know how to
            generate the destination address.

            NVUpdateCompletes for input variables means that they
            are completion indication of corresponding poll requests.
*******************************************************************************/
void  PollNV(int16 nvIndexIn)
{
    uint16    dim;
    int16     baseIndex;
    int16     i;

    if (nvIndexIn < 0 || nvIndexIn >= nmp->nvTableSize )
    {
        return; /* Must be a valid primary index. */
    }


    IsArrayNV(nvIndexIn, &dim, &baseIndex);
    if (nvIndexIn != baseIndex)
    {
        dim = 1; /* nvIndexIn is not the first item of array */
    }

    /* Scheduled one or more (for array) primary indices. */
    /* For array, nvIndexIn = baseIndex */
    for (i = nvIndexIn; i < nvIndexIn + dim; i++)
    {
        PollThisPrimary(i);
    }
}

/*******************************************************************************
Function:   PollArrayNV
Returns:    None
Purpose:    To poll a specific element of an array input network variable
            or any other network variable (i.e non-array).
Comment:    This function is called by the application program to poll
            a specific item of an array network input variable or any
            other network variable (non-array).

            Once the primary is schedules, we also schedule alias
            entries that map to this primary to make sure that we
            reach all possible output connections.

            This function only schedules these variables by placing
            them in a queue for later processing by APPSend function.
            APPSend will call PollVar function to actually send out
            polling requests.

            The addressing information is implicit. If the network
            input variables does not correspond to an address table
            entry, then it can be scheduled as we don't know how to
            generate the destination address.

            If arrayNVIndexIn corresponds to the base index of an array,
            the indexIn is used to get the specific item of the array to
            be polled. Othewise, indexIn is set to 0 so that any other
            array item or any other network variable can be passed.

            NVUpdateCompletes for input variables means that they
            are completion indication of corresponding poll requests.
*******************************************************************************/
void  PollArrayNV(int16 arrayNVIndexIn, int16 indexIn)
{
    uint16    dim;
    int16     baseIndex;
    int16     nvIndex;


    if (arrayNVIndexIn < 0 || arrayNVIndexIn >= nmp->nvTableSize)
    {
        return; /* Invalid index. */
    }

    /* if arrayNVIndexIn is not an array variable, then dim is set to 1
       and baseIndex is set to arrayNVIndexIn by IsArrayNV function */
    if (!IsArrayNV(arrayNVIndexIn, &dim, &baseIndex))
    {
        indexIn = 0; /* Simple network variable */
    }
    else if (baseIndex != arrayNVIndexIn)
    {
        indexIn = 0; /* Any other array item. don't use indexIn passed. */
    }

    if (indexIn < 0 || indexIn >= dim)
    {
        return; /* Invalid index */
    }

    nvIndex = arrayNVIndexIn + indexIn;
    PollThisPrimary(nvIndex);
}

/*******************************************************************************
Function:  PollVar
Returns:   None
Reference: Technology Device Data Book Rev 3. page 9-54.
Purpose:   Issues a poll message for a single network input variable.
           Sends NV Poll message for the connected output variables.

           If there exists a unique turnaround output, we update
           the network variable directly and send NVUpdateOccurs event
           to the application program. Thus, updates from externally
           connected output variables will arrive later.

Comments:  Note that this return value does not mean that the
           poll transaction is complete. It only means that the
           polling request has been delivered to the session layer.

           nvIndexIn must be good as it was previously scheduled.
           nvIndexIn can be either primary or alias.

           Do not check turnaround entries unless the session layer
           has space in the request queue for scheduling the poll.
           Otherwise, we may do the turnaround but stuck with not
           being able send the poll request. If we keep the entry
           in the queue after turnaround entries are processed, we
           may end up with double processing of turnaround entries.

           The NV Variable Poll message must be Request. So, use
           session layer.
*******************************************************************************/
static void PollVar(void)
{
    Queue          *indexQPtr;
    int16           nvIndex;
    int16          *indexPtr;
    int16           i;         /* For loop. */
    int16           primaryIndex; /* For nvIndex. */
    uint16          nvLength;     /* For nvIndex. */
    uint16          dim;          /* For nvIndex, if it is array */
    int16           baseIndex;    /* For nvIndex, if it is array */
    uint16          selector;     /* For nvIndex. */
    Byte           *nvPtr;        /* For nvIndex. Points to storage. */
    int16           primaryIndexOut; /* For output network variable */
    uint16          nvLengthOut;     /* For output network variable */
    Byte           *nvPtrOut;        /* For output network variable */
    uint16          selectorOut;     /* For output network variable */
    Queue          *tsaOutQPtr;
    TSASendParam   *tsaSendParamPtr;
    APDU           *apduPtr;
    NVStruct       *nvStrPtr, *nvStrPtrOut;
    uint16          addrIndex;
    AddrTableEntry *ap;
    Boolean         turnAroundOnly; /* does not mean turnaround for sure. Means that
                                      the variable does not have addr table entry
                                      or the address table entry is unbound or
                                      it is turnaround entry. */
    int16           matchingIndexOut;

    indexQPtr = &gp->nvInIndexQ;

    if (!gp->nvInCanSchedule || QueueEmpty(indexQPtr))
    {
        return;
    }
    indexPtr  = QueueHead(indexQPtr);
    nvIndex = *indexPtr;

    /* If the node enters unconfigued state before processing this nv poll
       we do not want to schedule these indices. We simply do nothing and wait
       for the node to go configured. */
    if (eep->readOnlyData.nodeState == APPL_UNCNFG)
    {
        return;
    }

    if (nvIndex >= 0)
    {
        /* Make nvStrPtr point to the right NVStruct for nvIndex */
        nvStrPtr     = GetNVStructPtr(nvIndex);
        /* START INFORMATIVE - Network Variable Alias Priority */
        /* The bracketed code in conjunction with other code in this implementation
         * is structured in a way which allows network variable aliases
         * to have a different priority attribute than the primary and for that
         * difference in priority to be honored.  It is acceptable, however, to send
         * all aliases using the same priority attribute as that of the primary. */
        if (nvStrPtr->nvPriority)
        {
            tsaOutQPtr = &gp->tsaOutPriQ;
        }
        else
        {
            tsaOutQPtr = &gp->tsaOutQ;
        }
        /* END INFORMATIVE - Network Variable Alias Priority */

        primaryIndex = GetPrimaryIndex(nvIndex);
        nvPtr        = NV_ADDRESS(primaryIndex);
        nvLength     = NV_LENGTH(primaryIndex);
        selector     = (nvStrPtr->nvSelectorHi << 8) | nvStrPtr->nvSelectorLo;
        addrIndex    = nvStrPtr->nvAddrIndex;
        /* The variable is turnaround only if addrIndex is 0xF or it is unbound
           (turnaround or not) */
        turnAroundOnly  = (addrIndex == 0xF) ||
                          (eep->addrTable[addrIndex].addrFormat == UNBOUND);
    }
    else
    {
        tsaOutQPtr = &gp->tsaOutQ;
    }
    /* If the address table entry is turnaround only, then we don't send out
       any nv poll messages and hence we don't need to check the queue
       for space availability */
    if (nvIndex == -1 || !turnAroundOnly)
    {
        if (QueueFull(tsaOutQPtr))
        {
            /* Can't send request yet - try later. Don't even try turnaround. */
            return;
        }
    }

    if (nvIndex == -1)
    {
        /* Form a message with a special tag to transport layer. */
        tsaSendParamPtr              = QueueTail(tsaOutQPtr);
        tsaSendParamPtr->altPathOverride = FALSE;
        tsaSendParamPtr->service     = ACKD;
        tsaSendParamPtr->tag         = NV_POLL_LAST_TAG_VALUE;
        tsaSendParamPtr->apduSize    = 0;
        EnQueue(tsaOutQPtr);
        gp->nvInCanSchedule = FALSE; /* Only one at a time. */
        DeQueue(indexQPtr);
        return;
    }

    /* If nvIndex is part of an array, we need to get the dimension and
       the baseIndex so that we can report nvInAddr and nvArrayIndex
       properly, in case there is a turn around connected. Alias entries
       can't be used to determine whether it is array. Use primaryIndex.
       We will use baseIndex for NVUpdateOccurs event */
    IsArrayNV(primaryIndex, &dim, &baseIndex);

    /* If the variable is flagged as turnaround, then we look for first
       network output variables with matching selector number. Once found,
       we update this input variable, and then send NVUpdateOccurs event
       to the application program. */
    if (nvStrPtr->nvTurnaround)
    {
        matchingIndexOut = -1;
        for (i = 0; i < nmp->nvTableSize+NV_ALIAS_TABLE_SIZE; i++)
        {
            nvStrPtrOut  = GetNVStructPtr(i);
            /* Skip input network variables */
            if (nvStrPtrOut->nvDirection == NV_INPUT)
            {
                continue;
            }
            /* It is a network output variable. Match selector */
            selectorOut =
                (nvStrPtrOut->nvSelectorHi << 8) | nvStrPtrOut->nvSelectorLo;
            if (selector != selectorOut)
            {
                continue; /* Selector does not match */
            }
            /* Found a matching output variable for nvIndex */
            matchingIndexOut = i;
            break;
        }

        if (matchingIndexOut != -1)
        {
            primaryIndexOut = GetPrimaryIndex(matchingIndexOut);
            nvPtrOut        = NV_ADDRESS(primaryIndexOut);
            nvLengthOut     = NV_LENGTH(primaryIndexOut);

            /* Update the input variable provided the length matches */
            if (nvLength == nvLengthOut)
            {
                /* We will skip authentication check as it is turnaround */
                memcpy(nvPtr, nvPtrOut, nvLength);

                /* turnaround updates are ignored for valid data check for polls.
                   The only time it is ignored is if the nv is turnaround only.
                   So, do not update gp->nvInDataStatus flag here. */

                /* Notify application program if it is running. */
                if (AppPgmRuns())
                {
                    gp->nvInAddr.format = 4; /* TURNAROUND */
                    memset(&gp->nvInAddr.srcAddr, 0, sizeof(SubnetAddress));
                    gp->nvInAddr.domain = 0; /* Not relevant */
                    /* gp->nvArrayIndex is 0 for simple var */
                    gp->nvArrayIndex    = primaryIndex - baseIndex;
                    /* same as primaryIndex for simple var */
                    NVUpdateOccurs(baseIndex, gp->nvArrayIndex);
                }
            }
        }
    }

    if (turnAroundOnly)
    {
        /* NV completion event is given in HandleMsgCompletion. */
        /* Don't clear the nvInCanSchedule flag as we can continue */
        /* Since this index does not go through HandleMsgCompletion, we need
           to set gp->nvInIndex here. This is to take care of the case when
           a variable is turndaround only with no alias. In this case, this index
           is followed by -1 in the queue. Hence, the gp->nvInIndex would never
           be initialized when HandleMsgCompletion gets NV_POLL_LAST_TAG_VALUE.
           Explicit initialization here will fix the problem. */
        gp->nvInIndex = GetPrimaryIndex(nvIndex);
        if (nvStrPtr->nvTurnaround && matchingIndexOut != -1)
        {
            /* We did find a matching output variable and updated the polled variable */
            /* Note that even if one of the indices (primary or alias) is turnaround
               only, this flag is set to true. */
            gp->nvInDataStatus = SUCCESS; /* to enable poll to succeed */
        }
        DeQueue(indexQPtr);
        return;
    }

    gp->nvInCanSchedule = FALSE;
    DeQueue(indexQPtr);

    /* Build and send netvar poll message. It is a REQUEST message. */
    ap = AccessAddress(addrIndex); /* ap can't be null */

    tsaSendParamPtr              = QueueTail(tsaOutQPtr);
    tsaSendParamPtr->altPathOverride = FALSE;
    tsaSendParamPtr->dmn.domainIndex = COMPUTE_DOMAIN_INDEX;
    *(AddrTableEntry *)(&tsaSendParamPtr->destAddr) = *ap;
    tsaSendParamPtr->service     = REQUEST; /* Poll Message */
    tsaSendParamPtr->auth        = nvStrPtr->nvAuth;
    /* See app.h for details on tag usage. */
    tsaSendParamPtr->tag         = GET_NV_POLL_TAG(primaryIndex);
    apduPtr                      = (APDU *)(tsaSendParamPtr + 1);
    apduPtr->code.nv.nvFlag      = 0x1;
    apduPtr->code.nv.nvDir       = NV_OUTPUT;
    apduPtr->code.nv.nvCode      = nvStrPtr->nvSelectorHi;
    apduPtr->data[0]             = nvStrPtr->nvSelectorLo;
    tsaSendParamPtr->apduSize    = 2;

    EnQueue(tsaOutQPtr);
    return;
}

/*******************************************************************************
Function: NewMsgTag
Returns:  A new message tag of the requested type (bindable or non-bindable).
Purpose:  To allocate message tags for use by application program.
Comment:  Reference implementation does not support rate information
          for tags.
********************************************************************************/
MsgTag NewMsgTag(BindNoBind bindStatusIn)
{
    if (bindStatusIn == BIND)
    {
        if (gp->nextBindableMsgTag < NUM_ADDR_TBL_ENTRIES &&
                nmp->snvt.mtagCount < 0xFF)
        {
            nmp->snvt.mtagCount++;
            return(gp->nextBindableMsgTag++);
        }
        else
        {
            /* Ran out of addr table entries or no room in mtagCount. */
            return(-1);
        }
    }

    if (gp->nextNonbindableMsgTag < 0xFFFF)
    {
        return(gp->nextNonbindableMsgTag++); /* We have lots of this */
    }
    else
    {
        return(-1); /* Extremely unlikely to happen. */
    }
}

/*******************************************************************************
Function:  IsArrayNV
Returns:   Returns TRUE if a given primary index corresponds to a
           network array variable.
           The index can be any of the indices for the array
           elements.
Reference: None
Purpose:   To determine if an index corresponds to a network
           array variable. This is needed as this info is not part
           of the nv config or fixed tables.
           For simple variables, dimOut is set to 1 and baseIndexOut
           is set to the given index. (By default).
Comments:  gp->nvArrayTbl is an array of structures with two
           fields: nvIndex and dim. The table contains nvIndex
           and dim only for array variables. The table is populated
           during AddNV.
           For array variables, dim (dimension of array) and array
           base index passed back if provided with non-null addresses.
*******************************************************************************/
static Boolean IsArrayNV(int16 nvIndexIn,
                         uint16 *dimOut, int16 *baseIndexOut)
{
    int16 i;

    if (dimOut)
    {
        *dimOut = 1; /* Default for simple variables */
    }
    if (baseIndexOut)
    {
        *baseIndexOut = nvIndexIn;
    }
    /* Sequential search. OK if there are not too many arrays. */
    if (nvIndexIn < 0 || nvIndexIn >= nmp->nvTableSize)
    {
        return(FALSE); /* Only primary variables can be arrays */
    }
    for (i = 0; i < gp->nvArrayTblSize; i++)
    {
        if (nvIndexIn >= gp->nvArrayTbl[i].nvIndex &&
                nvIndexIn <  gp->nvArrayTbl[i].nvIndex + gp->nvArrayTbl[i].dim)
        {
            /* Lies in the range for this array variable */
            if (dimOut)
            {
                *dimOut   = gp->nvArrayTbl[i].dim;
            }
            if (baseIndexOut)
            {
                *baseIndexOut = gp->nvArrayTbl[i].nvIndex;
            }
            return(TRUE);
        }
    }
    return(FALSE); /* Not found. Must be a simple variable */
}

/* Application can call this fn to put itself offline */
void GoOffline(void)
{
    OfflineEvent();
    gp->appPgmMode = OFF_LINE;
}

/* Appplication can call this fn to put itself unconfigured */
void GoUnconfigured(void)
{
    int i, numDomains;

    eep->readOnlyData.nodeState = APPL_UNCNFG;
    /* Set appPgmMode to OFF_LINE so that when we configured again, the
       application program will be soft-off-line.
       See P9-47 of Tech Device Data Book Rev 3 */
    gp->appPgmMode              = OFF_LINE;
    if (eep->readOnlyData.twoDomains)
    {
        numDomains = 2;
    }
    else
    {
        numDomains = 1;
    }

    /* Overwrite all domain information. Destroys auth key */
    for (i = 0; i < numDomains; i++)
    {
	    memset(&eep->domainTable[i], 0xFF, sizeof(eep->domainTable[0]));
        memcpy(eep->domainTable[i].domainId, "gmrdwf", DOMAIN_ID_LEN);
        eep->domainTable[i].subnet = 0;
        eep->domainTable[i].cloneDomain = 0;
        eep->domainTable[i].node = 0;
     }
}

/*-----------------------------------End of app.c-----------------------------*/
